/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/hast-util-to-jsx-runtime";
exports.ids = ["vendor-chunks/hast-util-to-jsx-runtime"];
exports.modules = {

/***/ "(ssr)/../node_modules/hast-util-to-jsx-runtime/node_modules/inline-style-parser/index.js":
/*!******************************************************************************************!*\
  !*** ../node_modules/hast-util-to-jsx-runtime/node_modules/inline-style-parser/index.js ***!
  \******************************************************************************************/
/***/ ((module) => {

eval("// http://www.w3.org/TR/CSS21/grammar.html\n// https://github.com/visionmedia/css-parse/pull/49#issuecomment-30088027\nvar COMMENT_REGEX = /\\/\\*[^*]*\\*+([^/*][^*]*\\*+)*\\//g;\n\nvar NEWLINE_REGEX = /\\n/g;\nvar WHITESPACE_REGEX = /^\\s*/;\n\n// declaration\nvar PROPERTY_REGEX = /^(\\*?[-#/*\\\\\\w]+(\\[[0-9a-z_-]+\\])?)\\s*/;\nvar COLON_REGEX = /^:\\s*/;\nvar VALUE_REGEX = /^((?:'(?:\\\\'|.)*?'|\"(?:\\\\\"|.)*?\"|\\([^)]*?\\)|[^};])+)/;\nvar SEMICOLON_REGEX = /^[;\\s]*/;\n\n// https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim#Polyfill\nvar TRIM_REGEX = /^\\s+|\\s+$/g;\n\n// strings\nvar NEWLINE = '\\n';\nvar FORWARD_SLASH = '/';\nvar ASTERISK = '*';\nvar EMPTY_STRING = '';\n\n// types\nvar TYPE_COMMENT = 'comment';\nvar TYPE_DECLARATION = 'declaration';\n\n/**\n * @param {String} style\n * @param {Object} [options]\n * @return {Object[]}\n * @throws {TypeError}\n * @throws {Error}\n */\nmodule.exports = function (style, options) {\n  if (typeof style !== 'string') {\n    throw new TypeError('First argument must be a string');\n  }\n\n  if (!style) return [];\n\n  options = options || {};\n\n  /**\n   * Positional.\n   */\n  var lineno = 1;\n  var column = 1;\n\n  /**\n   * Update lineno and column based on `str`.\n   *\n   * @param {String} str\n   */\n  function updatePosition(str) {\n    var lines = str.match(NEWLINE_REGEX);\n    if (lines) lineno += lines.length;\n    var i = str.lastIndexOf(NEWLINE);\n    column = ~i ? str.length - i : column + str.length;\n  }\n\n  /**\n   * Mark position and patch `node.position`.\n   *\n   * @return {Function}\n   */\n  function position() {\n    var start = { line: lineno, column: column };\n    return function (node) {\n      node.position = new Position(start);\n      whitespace();\n      return node;\n    };\n  }\n\n  /**\n   * Store position information for a node.\n   *\n   * @constructor\n   * @property {Object} start\n   * @property {Object} end\n   * @property {undefined|String} source\n   */\n  function Position(start) {\n    this.start = start;\n    this.end = { line: lineno, column: column };\n    this.source = options.source;\n  }\n\n  /**\n   * Non-enumerable source string.\n   */\n  Position.prototype.content = style;\n\n  var errorsList = [];\n\n  /**\n   * Error `msg`.\n   *\n   * @param {String} msg\n   * @throws {Error}\n   */\n  function error(msg) {\n    var err = new Error(\n      options.source + ':' + lineno + ':' + column + ': ' + msg\n    );\n    err.reason = msg;\n    err.filename = options.source;\n    err.line = lineno;\n    err.column = column;\n    err.source = style;\n\n    if (options.silent) {\n      errorsList.push(err);\n    } else {\n      throw err;\n    }\n  }\n\n  /**\n   * Match `re` and return captures.\n   *\n   * @param {RegExp} re\n   * @return {undefined|Array}\n   */\n  function match(re) {\n    var m = re.exec(style);\n    if (!m) return;\n    var str = m[0];\n    updatePosition(str);\n    style = style.slice(str.length);\n    return m;\n  }\n\n  /**\n   * Parse whitespace.\n   */\n  function whitespace() {\n    match(WHITESPACE_REGEX);\n  }\n\n  /**\n   * Parse comments.\n   *\n   * @param {Object[]} [rules]\n   * @return {Object[]}\n   */\n  function comments(rules) {\n    var c;\n    rules = rules || [];\n    while ((c = comment())) {\n      if (c !== false) {\n        rules.push(c);\n      }\n    }\n    return rules;\n  }\n\n  /**\n   * Parse comment.\n   *\n   * @return {Object}\n   * @throws {Error}\n   */\n  function comment() {\n    var pos = position();\n    if (FORWARD_SLASH != style.charAt(0) || ASTERISK != style.charAt(1)) return;\n\n    var i = 2;\n    while (\n      EMPTY_STRING != style.charAt(i) &&\n      (ASTERISK != style.charAt(i) || FORWARD_SLASH != style.charAt(i + 1))\n    ) {\n      ++i;\n    }\n    i += 2;\n\n    if (EMPTY_STRING === style.charAt(i - 1)) {\n      return error('End of comment missing');\n    }\n\n    var str = style.slice(2, i - 2);\n    column += 2;\n    updatePosition(str);\n    style = style.slice(i);\n    column += 2;\n\n    return pos({\n      type: TYPE_COMMENT,\n      comment: str\n    });\n  }\n\n  /**\n   * Parse declaration.\n   *\n   * @return {Object}\n   * @throws {Error}\n   */\n  function declaration() {\n    var pos = position();\n\n    // prop\n    var prop = match(PROPERTY_REGEX);\n    if (!prop) return;\n    comment();\n\n    // :\n    if (!match(COLON_REGEX)) return error(\"property missing ':'\");\n\n    // val\n    var val = match(VALUE_REGEX);\n\n    var ret = pos({\n      type: TYPE_DECLARATION,\n      property: trim(prop[0].replace(COMMENT_REGEX, EMPTY_STRING)),\n      value: val\n        ? trim(val[0].replace(COMMENT_REGEX, EMPTY_STRING))\n        : EMPTY_STRING\n    });\n\n    // ;\n    match(SEMICOLON_REGEX);\n\n    return ret;\n  }\n\n  /**\n   * Parse declarations.\n   *\n   * @return {Object[]}\n   */\n  function declarations() {\n    var decls = [];\n\n    comments(decls);\n\n    // declarations\n    var decl;\n    while ((decl = declaration())) {\n      if (decl !== false) {\n        decls.push(decl);\n        comments(decls);\n      }\n    }\n\n    return decls;\n  }\n\n  whitespace();\n  return declarations();\n};\n\n/**\n * Trim `str`.\n *\n * @param {String} str\n * @return {String}\n */\nfunction trim(str) {\n  return str ? str.replace(TRIM_REGEX, EMPTY_STRING) : EMPTY_STRING;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2hhc3QtdXRpbC10by1qc3gtcnVudGltZS9ub2RlX21vZHVsZXMvaW5saW5lLXN0eWxlLXBhcnNlci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkUsMEJBQTBCOztBQUUxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1osWUFBWTtBQUNaLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ2l0aHViX215X3BvcnRmb2xpby8uLi9ub2RlX21vZHVsZXMvaGFzdC11dGlsLXRvLWpzeC1ydW50aW1lL25vZGVfbW9kdWxlcy9pbmxpbmUtc3R5bGUtcGFyc2VyL2luZGV4LmpzPzYyMjUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvZ3JhbW1hci5odG1sXG4vLyBodHRwczovL2dpdGh1Yi5jb20vdmlzaW9ubWVkaWEvY3NzLXBhcnNlL3B1bGwvNDkjaXNzdWVjb21tZW50LTMwMDg4MDI3XG52YXIgQ09NTUVOVF9SRUdFWCA9IC9cXC9cXCpbXipdKlxcKisoW14vKl1bXipdKlxcKispKlxcLy9nO1xuXG52YXIgTkVXTElORV9SRUdFWCA9IC9cXG4vZztcbnZhciBXSElURVNQQUNFX1JFR0VYID0gL15cXHMqLztcblxuLy8gZGVjbGFyYXRpb25cbnZhciBQUk9QRVJUWV9SRUdFWCA9IC9eKFxcKj9bLSMvKlxcXFxcXHddKyhcXFtbMC05YS16Xy1dK1xcXSk/KVxccyovO1xudmFyIENPTE9OX1JFR0VYID0gL146XFxzKi87XG52YXIgVkFMVUVfUkVHRVggPSAvXigoPzonKD86XFxcXCd8LikqPyd8XCIoPzpcXFxcXCJ8LikqP1wifFxcKFteKV0qP1xcKXxbXn07XSkrKS87XG52YXIgU0VNSUNPTE9OX1JFR0VYID0gL15bO1xcc10qLztcblxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL1RyaW0jUG9seWZpbGxcbnZhciBUUklNX1JFR0VYID0gL15cXHMrfFxccyskL2c7XG5cbi8vIHN0cmluZ3NcbnZhciBORVdMSU5FID0gJ1xcbic7XG52YXIgRk9SV0FSRF9TTEFTSCA9ICcvJztcbnZhciBBU1RFUklTSyA9ICcqJztcbnZhciBFTVBUWV9TVFJJTkcgPSAnJztcblxuLy8gdHlwZXNcbnZhciBUWVBFX0NPTU1FTlQgPSAnY29tbWVudCc7XG52YXIgVFlQRV9ERUNMQVJBVElPTiA9ICdkZWNsYXJhdGlvbic7XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0eWxlXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcmV0dXJuIHtPYmplY3RbXX1cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn1cbiAqIEB0aHJvd3Mge0Vycm9yfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHlsZSwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIHN0eWxlICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgfVxuXG4gIGlmICghc3R5bGUpIHJldHVybiBbXTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvKipcbiAgICogUG9zaXRpb25hbC5cbiAgICovXG4gIHZhciBsaW5lbm8gPSAxO1xuICB2YXIgY29sdW1uID0gMTtcblxuICAvKipcbiAgICogVXBkYXRlIGxpbmVubyBhbmQgY29sdW1uIGJhc2VkIG9uIGBzdHJgLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gICAqL1xuICBmdW5jdGlvbiB1cGRhdGVQb3NpdGlvbihzdHIpIHtcbiAgICB2YXIgbGluZXMgPSBzdHIubWF0Y2goTkVXTElORV9SRUdFWCk7XG4gICAgaWYgKGxpbmVzKSBsaW5lbm8gKz0gbGluZXMubGVuZ3RoO1xuICAgIHZhciBpID0gc3RyLmxhc3RJbmRleE9mKE5FV0xJTkUpO1xuICAgIGNvbHVtbiA9IH5pID8gc3RyLmxlbmd0aCAtIGkgOiBjb2x1bW4gKyBzdHIubGVuZ3RoO1xuICB9XG5cbiAgLyoqXG4gICAqIE1hcmsgcG9zaXRpb24gYW5kIHBhdGNoIGBub2RlLnBvc2l0aW9uYC5cbiAgICpcbiAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAqL1xuICBmdW5jdGlvbiBwb3NpdGlvbigpIHtcbiAgICB2YXIgc3RhcnQgPSB7IGxpbmU6IGxpbmVubywgY29sdW1uOiBjb2x1bW4gfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIG5vZGUucG9zaXRpb24gPSBuZXcgUG9zaXRpb24oc3RhcnQpO1xuICAgICAgd2hpdGVzcGFjZSgpO1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9yZSBwb3NpdGlvbiBpbmZvcm1hdGlvbiBmb3IgYSBub2RlLlxuICAgKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHByb3BlcnR5IHtPYmplY3R9IHN0YXJ0XG4gICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBlbmRcbiAgICogQHByb3BlcnR5IHt1bmRlZmluZWR8U3RyaW5nfSBzb3VyY2VcbiAgICovXG4gIGZ1bmN0aW9uIFBvc2l0aW9uKHN0YXJ0KSB7XG4gICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgIHRoaXMuZW5kID0geyBsaW5lOiBsaW5lbm8sIGNvbHVtbjogY29sdW1uIH07XG4gICAgdGhpcy5zb3VyY2UgPSBvcHRpb25zLnNvdXJjZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBOb24tZW51bWVyYWJsZSBzb3VyY2Ugc3RyaW5nLlxuICAgKi9cbiAgUG9zaXRpb24ucHJvdG90eXBlLmNvbnRlbnQgPSBzdHlsZTtcblxuICB2YXIgZXJyb3JzTGlzdCA9IFtdO1xuXG4gIC8qKlxuICAgKiBFcnJvciBgbXNnYC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1zZ1xuICAgKiBAdGhyb3dzIHtFcnJvcn1cbiAgICovXG4gIGZ1bmN0aW9uIGVycm9yKG1zZykge1xuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoXG4gICAgICBvcHRpb25zLnNvdXJjZSArICc6JyArIGxpbmVubyArICc6JyArIGNvbHVtbiArICc6ICcgKyBtc2dcbiAgICApO1xuICAgIGVyci5yZWFzb24gPSBtc2c7XG4gICAgZXJyLmZpbGVuYW1lID0gb3B0aW9ucy5zb3VyY2U7XG4gICAgZXJyLmxpbmUgPSBsaW5lbm87XG4gICAgZXJyLmNvbHVtbiA9IGNvbHVtbjtcbiAgICBlcnIuc291cmNlID0gc3R5bGU7XG5cbiAgICBpZiAob3B0aW9ucy5zaWxlbnQpIHtcbiAgICAgIGVycm9yc0xpc3QucHVzaChlcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1hdGNoIGByZWAgYW5kIHJldHVybiBjYXB0dXJlcy5cbiAgICpcbiAgICogQHBhcmFtIHtSZWdFeHB9IHJlXG4gICAqIEByZXR1cm4ge3VuZGVmaW5lZHxBcnJheX1cbiAgICovXG4gIGZ1bmN0aW9uIG1hdGNoKHJlKSB7XG4gICAgdmFyIG0gPSByZS5leGVjKHN0eWxlKTtcbiAgICBpZiAoIW0pIHJldHVybjtcbiAgICB2YXIgc3RyID0gbVswXTtcbiAgICB1cGRhdGVQb3NpdGlvbihzdHIpO1xuICAgIHN0eWxlID0gc3R5bGUuc2xpY2Uoc3RyLmxlbmd0aCk7XG4gICAgcmV0dXJuIG07XG4gIH1cblxuICAvKipcbiAgICogUGFyc2Ugd2hpdGVzcGFjZS5cbiAgICovXG4gIGZ1bmN0aW9uIHdoaXRlc3BhY2UoKSB7XG4gICAgbWF0Y2goV0hJVEVTUEFDRV9SRUdFWCk7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgY29tbWVudHMuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0W119IFtydWxlc11cbiAgICogQHJldHVybiB7T2JqZWN0W119XG4gICAqL1xuICBmdW5jdGlvbiBjb21tZW50cyhydWxlcykge1xuICAgIHZhciBjO1xuICAgIHJ1bGVzID0gcnVsZXMgfHwgW107XG4gICAgd2hpbGUgKChjID0gY29tbWVudCgpKSkge1xuICAgICAgaWYgKGMgIT09IGZhbHNlKSB7XG4gICAgICAgIHJ1bGVzLnB1c2goYyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBydWxlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBjb21tZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqIEB0aHJvd3Mge0Vycm9yfVxuICAgKi9cbiAgZnVuY3Rpb24gY29tbWVudCgpIHtcbiAgICB2YXIgcG9zID0gcG9zaXRpb24oKTtcbiAgICBpZiAoRk9SV0FSRF9TTEFTSCAhPSBzdHlsZS5jaGFyQXQoMCkgfHwgQVNURVJJU0sgIT0gc3R5bGUuY2hhckF0KDEpKSByZXR1cm47XG5cbiAgICB2YXIgaSA9IDI7XG4gICAgd2hpbGUgKFxuICAgICAgRU1QVFlfU1RSSU5HICE9IHN0eWxlLmNoYXJBdChpKSAmJlxuICAgICAgKEFTVEVSSVNLICE9IHN0eWxlLmNoYXJBdChpKSB8fCBGT1JXQVJEX1NMQVNIICE9IHN0eWxlLmNoYXJBdChpICsgMSkpXG4gICAgKSB7XG4gICAgICArK2k7XG4gICAgfVxuICAgIGkgKz0gMjtcblxuICAgIGlmIChFTVBUWV9TVFJJTkcgPT09IHN0eWxlLmNoYXJBdChpIC0gMSkpIHtcbiAgICAgIHJldHVybiBlcnJvcignRW5kIG9mIGNvbW1lbnQgbWlzc2luZycpO1xuICAgIH1cblxuICAgIHZhciBzdHIgPSBzdHlsZS5zbGljZSgyLCBpIC0gMik7XG4gICAgY29sdW1uICs9IDI7XG4gICAgdXBkYXRlUG9zaXRpb24oc3RyKTtcbiAgICBzdHlsZSA9IHN0eWxlLnNsaWNlKGkpO1xuICAgIGNvbHVtbiArPSAyO1xuXG4gICAgcmV0dXJuIHBvcyh7XG4gICAgICB0eXBlOiBUWVBFX0NPTU1FTlQsXG4gICAgICBjb21tZW50OiBzdHJcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBkZWNsYXJhdGlvbi5cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiBAdGhyb3dzIHtFcnJvcn1cbiAgICovXG4gIGZ1bmN0aW9uIGRlY2xhcmF0aW9uKCkge1xuICAgIHZhciBwb3MgPSBwb3NpdGlvbigpO1xuXG4gICAgLy8gcHJvcFxuICAgIHZhciBwcm9wID0gbWF0Y2goUFJPUEVSVFlfUkVHRVgpO1xuICAgIGlmICghcHJvcCkgcmV0dXJuO1xuICAgIGNvbW1lbnQoKTtcblxuICAgIC8vIDpcbiAgICBpZiAoIW1hdGNoKENPTE9OX1JFR0VYKSkgcmV0dXJuIGVycm9yKFwicHJvcGVydHkgbWlzc2luZyAnOidcIik7XG5cbiAgICAvLyB2YWxcbiAgICB2YXIgdmFsID0gbWF0Y2goVkFMVUVfUkVHRVgpO1xuXG4gICAgdmFyIHJldCA9IHBvcyh7XG4gICAgICB0eXBlOiBUWVBFX0RFQ0xBUkFUSU9OLFxuICAgICAgcHJvcGVydHk6IHRyaW0ocHJvcFswXS5yZXBsYWNlKENPTU1FTlRfUkVHRVgsIEVNUFRZX1NUUklORykpLFxuICAgICAgdmFsdWU6IHZhbFxuICAgICAgICA/IHRyaW0odmFsWzBdLnJlcGxhY2UoQ09NTUVOVF9SRUdFWCwgRU1QVFlfU1RSSU5HKSlcbiAgICAgICAgOiBFTVBUWV9TVFJJTkdcbiAgICB9KTtcblxuICAgIC8vIDtcbiAgICBtYXRjaChTRU1JQ09MT05fUkVHRVgpO1xuXG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBkZWNsYXJhdGlvbnMuXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdFtdfVxuICAgKi9cbiAgZnVuY3Rpb24gZGVjbGFyYXRpb25zKCkge1xuICAgIHZhciBkZWNscyA9IFtdO1xuXG4gICAgY29tbWVudHMoZGVjbHMpO1xuXG4gICAgLy8gZGVjbGFyYXRpb25zXG4gICAgdmFyIGRlY2w7XG4gICAgd2hpbGUgKChkZWNsID0gZGVjbGFyYXRpb24oKSkpIHtcbiAgICAgIGlmIChkZWNsICE9PSBmYWxzZSkge1xuICAgICAgICBkZWNscy5wdXNoKGRlY2wpO1xuICAgICAgICBjb21tZW50cyhkZWNscyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlY2xzO1xuICB9XG5cbiAgd2hpdGVzcGFjZSgpO1xuICByZXR1cm4gZGVjbGFyYXRpb25zKCk7XG59O1xuXG4vKipcbiAqIFRyaW0gYHN0cmAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiB0cmltKHN0cikge1xuICByZXR1cm4gc3RyID8gc3RyLnJlcGxhY2UoVFJJTV9SRUdFWCwgRU1QVFlfU1RSSU5HKSA6IEVNUFRZX1NUUklORztcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/hast-util-to-jsx-runtime/node_modules/inline-style-parser/index.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/hast-util-to-jsx-runtime/node_modules/style-to-object/cjs/index.js":
/*!******************************************************************************************!*\
  !*** ../node_modules/hast-util-to-jsx-runtime/node_modules/style-to-object/cjs/index.js ***!
  \******************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports[\"default\"] = StyleToObject;\nvar inline_style_parser_1 = __importDefault(__webpack_require__(/*! inline-style-parser */ \"(ssr)/../node_modules/hast-util-to-jsx-runtime/node_modules/inline-style-parser/index.js\"));\n/**\n * Parses inline style to object.\n *\n * @param style - Inline style.\n * @param iterator - Iterator.\n * @returns - Style object or null.\n *\n * @example Parsing inline style to object:\n *\n * ```js\n * import parse from 'style-to-object';\n * parse('line-height: 42;'); // { 'line-height': '42' }\n * ```\n */\nfunction StyleToObject(style, iterator) {\n    var styleObject = null;\n    if (!style || typeof style !== 'string') {\n        return styleObject;\n    }\n    var declarations = (0, inline_style_parser_1.default)(style);\n    var hasIterator = typeof iterator === 'function';\n    declarations.forEach(function (declaration) {\n        if (declaration.type !== 'declaration') {\n            return;\n        }\n        var property = declaration.property, value = declaration.value;\n        if (hasIterator) {\n            iterator(property, value, declaration);\n        }\n        else if (value) {\n            styleObject = styleObject || {};\n            styleObject[property] = value;\n        }\n    });\n    return styleObject;\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2hhc3QtdXRpbC10by1qc3gtcnVudGltZS9ub2RlX21vZHVsZXMvc3R5bGUtdG8tb2JqZWN0L2Nqcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFlO0FBQ2YsNENBQTRDLG1CQUFPLENBQUMscUhBQXFCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsSUFBSSxLQUFLO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9naXRodWJfbXlfcG9ydGZvbGlvLy4uL25vZGVfbW9kdWxlcy9oYXN0LXV0aWwtdG8tanN4LXJ1bnRpbWUvbm9kZV9tb2R1bGVzL3N0eWxlLXRvLW9iamVjdC9janMvaW5kZXguanM/ZTY5YiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IFN0eWxlVG9PYmplY3Q7XG52YXIgaW5saW5lX3N0eWxlX3BhcnNlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJpbmxpbmUtc3R5bGUtcGFyc2VyXCIpKTtcbi8qKlxuICogUGFyc2VzIGlubGluZSBzdHlsZSB0byBvYmplY3QuXG4gKlxuICogQHBhcmFtIHN0eWxlIC0gSW5saW5lIHN0eWxlLlxuICogQHBhcmFtIGl0ZXJhdG9yIC0gSXRlcmF0b3IuXG4gKiBAcmV0dXJucyAtIFN0eWxlIG9iamVjdCBvciBudWxsLlxuICpcbiAqIEBleGFtcGxlIFBhcnNpbmcgaW5saW5lIHN0eWxlIHRvIG9iamVjdDpcbiAqXG4gKiBgYGBqc1xuICogaW1wb3J0IHBhcnNlIGZyb20gJ3N0eWxlLXRvLW9iamVjdCc7XG4gKiBwYXJzZSgnbGluZS1oZWlnaHQ6IDQyOycpOyAvLyB7ICdsaW5lLWhlaWdodCc6ICc0MicgfVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIFN0eWxlVG9PYmplY3Qoc3R5bGUsIGl0ZXJhdG9yKSB7XG4gICAgdmFyIHN0eWxlT2JqZWN0ID0gbnVsbDtcbiAgICBpZiAoIXN0eWxlIHx8IHR5cGVvZiBzdHlsZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHN0eWxlT2JqZWN0O1xuICAgIH1cbiAgICB2YXIgZGVjbGFyYXRpb25zID0gKDAsIGlubGluZV9zdHlsZV9wYXJzZXJfMS5kZWZhdWx0KShzdHlsZSk7XG4gICAgdmFyIGhhc0l0ZXJhdG9yID0gdHlwZW9mIGl0ZXJhdG9yID09PSAnZnVuY3Rpb24nO1xuICAgIGRlY2xhcmF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChkZWNsYXJhdGlvbikge1xuICAgICAgICBpZiAoZGVjbGFyYXRpb24udHlwZSAhPT0gJ2RlY2xhcmF0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcm9wZXJ0eSA9IGRlY2xhcmF0aW9uLnByb3BlcnR5LCB2YWx1ZSA9IGRlY2xhcmF0aW9uLnZhbHVlO1xuICAgICAgICBpZiAoaGFzSXRlcmF0b3IpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKHByb3BlcnR5LCB2YWx1ZSwgZGVjbGFyYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBzdHlsZU9iamVjdCA9IHN0eWxlT2JqZWN0IHx8IHt9O1xuICAgICAgICAgICAgc3R5bGVPYmplY3RbcHJvcGVydHldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gc3R5bGVPYmplY3Q7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/hast-util-to-jsx-runtime/node_modules/style-to-object/cjs/index.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/hast-util-to-jsx-runtime/node_modules/inline-style-parser/index.js":
/*!******************************************************************************************!*\
  !*** ../node_modules/hast-util-to-jsx-runtime/node_modules/inline-style-parser/index.js ***!
  \******************************************************************************************/
/***/ ((module) => {

eval("// http://www.w3.org/TR/CSS21/grammar.html\n// https://github.com/visionmedia/css-parse/pull/49#issuecomment-30088027\nvar COMMENT_REGEX = /\\/\\*[^*]*\\*+([^/*][^*]*\\*+)*\\//g;\n\nvar NEWLINE_REGEX = /\\n/g;\nvar WHITESPACE_REGEX = /^\\s*/;\n\n// declaration\nvar PROPERTY_REGEX = /^(\\*?[-#/*\\\\\\w]+(\\[[0-9a-z_-]+\\])?)\\s*/;\nvar COLON_REGEX = /^:\\s*/;\nvar VALUE_REGEX = /^((?:'(?:\\\\'|.)*?'|\"(?:\\\\\"|.)*?\"|\\([^)]*?\\)|[^};])+)/;\nvar SEMICOLON_REGEX = /^[;\\s]*/;\n\n// https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim#Polyfill\nvar TRIM_REGEX = /^\\s+|\\s+$/g;\n\n// strings\nvar NEWLINE = '\\n';\nvar FORWARD_SLASH = '/';\nvar ASTERISK = '*';\nvar EMPTY_STRING = '';\n\n// types\nvar TYPE_COMMENT = 'comment';\nvar TYPE_DECLARATION = 'declaration';\n\n/**\n * @param {String} style\n * @param {Object} [options]\n * @return {Object[]}\n * @throws {TypeError}\n * @throws {Error}\n */\nmodule.exports = function (style, options) {\n  if (typeof style !== 'string') {\n    throw new TypeError('First argument must be a string');\n  }\n\n  if (!style) return [];\n\n  options = options || {};\n\n  /**\n   * Positional.\n   */\n  var lineno = 1;\n  var column = 1;\n\n  /**\n   * Update lineno and column based on `str`.\n   *\n   * @param {String} str\n   */\n  function updatePosition(str) {\n    var lines = str.match(NEWLINE_REGEX);\n    if (lines) lineno += lines.length;\n    var i = str.lastIndexOf(NEWLINE);\n    column = ~i ? str.length - i : column + str.length;\n  }\n\n  /**\n   * Mark position and patch `node.position`.\n   *\n   * @return {Function}\n   */\n  function position() {\n    var start = { line: lineno, column: column };\n    return function (node) {\n      node.position = new Position(start);\n      whitespace();\n      return node;\n    };\n  }\n\n  /**\n   * Store position information for a node.\n   *\n   * @constructor\n   * @property {Object} start\n   * @property {Object} end\n   * @property {undefined|String} source\n   */\n  function Position(start) {\n    this.start = start;\n    this.end = { line: lineno, column: column };\n    this.source = options.source;\n  }\n\n  /**\n   * Non-enumerable source string.\n   */\n  Position.prototype.content = style;\n\n  var errorsList = [];\n\n  /**\n   * Error `msg`.\n   *\n   * @param {String} msg\n   * @throws {Error}\n   */\n  function error(msg) {\n    var err = new Error(\n      options.source + ':' + lineno + ':' + column + ': ' + msg\n    );\n    err.reason = msg;\n    err.filename = options.source;\n    err.line = lineno;\n    err.column = column;\n    err.source = style;\n\n    if (options.silent) {\n      errorsList.push(err);\n    } else {\n      throw err;\n    }\n  }\n\n  /**\n   * Match `re` and return captures.\n   *\n   * @param {RegExp} re\n   * @return {undefined|Array}\n   */\n  function match(re) {\n    var m = re.exec(style);\n    if (!m) return;\n    var str = m[0];\n    updatePosition(str);\n    style = style.slice(str.length);\n    return m;\n  }\n\n  /**\n   * Parse whitespace.\n   */\n  function whitespace() {\n    match(WHITESPACE_REGEX);\n  }\n\n  /**\n   * Parse comments.\n   *\n   * @param {Object[]} [rules]\n   * @return {Object[]}\n   */\n  function comments(rules) {\n    var c;\n    rules = rules || [];\n    while ((c = comment())) {\n      if (c !== false) {\n        rules.push(c);\n      }\n    }\n    return rules;\n  }\n\n  /**\n   * Parse comment.\n   *\n   * @return {Object}\n   * @throws {Error}\n   */\n  function comment() {\n    var pos = position();\n    if (FORWARD_SLASH != style.charAt(0) || ASTERISK != style.charAt(1)) return;\n\n    var i = 2;\n    while (\n      EMPTY_STRING != style.charAt(i) &&\n      (ASTERISK != style.charAt(i) || FORWARD_SLASH != style.charAt(i + 1))\n    ) {\n      ++i;\n    }\n    i += 2;\n\n    if (EMPTY_STRING === style.charAt(i - 1)) {\n      return error('End of comment missing');\n    }\n\n    var str = style.slice(2, i - 2);\n    column += 2;\n    updatePosition(str);\n    style = style.slice(i);\n    column += 2;\n\n    return pos({\n      type: TYPE_COMMENT,\n      comment: str\n    });\n  }\n\n  /**\n   * Parse declaration.\n   *\n   * @return {Object}\n   * @throws {Error}\n   */\n  function declaration() {\n    var pos = position();\n\n    // prop\n    var prop = match(PROPERTY_REGEX);\n    if (!prop) return;\n    comment();\n\n    // :\n    if (!match(COLON_REGEX)) return error(\"property missing ':'\");\n\n    // val\n    var val = match(VALUE_REGEX);\n\n    var ret = pos({\n      type: TYPE_DECLARATION,\n      property: trim(prop[0].replace(COMMENT_REGEX, EMPTY_STRING)),\n      value: val\n        ? trim(val[0].replace(COMMENT_REGEX, EMPTY_STRING))\n        : EMPTY_STRING\n    });\n\n    // ;\n    match(SEMICOLON_REGEX);\n\n    return ret;\n  }\n\n  /**\n   * Parse declarations.\n   *\n   * @return {Object[]}\n   */\n  function declarations() {\n    var decls = [];\n\n    comments(decls);\n\n    // declarations\n    var decl;\n    while ((decl = declaration())) {\n      if (decl !== false) {\n        decls.push(decl);\n        comments(decls);\n      }\n    }\n\n    return decls;\n  }\n\n  whitespace();\n  return declarations();\n};\n\n/**\n * Trim `str`.\n *\n * @param {String} str\n * @return {String}\n */\nfunction trim(str) {\n  return str ? str.replace(TRIM_REGEX, EMPTY_STRING) : EMPTY_STRING;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2hhc3QtdXRpbC10by1qc3gtcnVudGltZS9ub2RlX21vZHVsZXMvaW5saW5lLXN0eWxlLXBhcnNlci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkUsMEJBQTBCOztBQUUxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1osWUFBWTtBQUNaLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ2l0aHViX215X3BvcnRmb2xpby8uLi9ub2RlX21vZHVsZXMvaGFzdC11dGlsLXRvLWpzeC1ydW50aW1lL25vZGVfbW9kdWxlcy9pbmxpbmUtc3R5bGUtcGFyc2VyL2luZGV4LmpzPzJlNjUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvZ3JhbW1hci5odG1sXG4vLyBodHRwczovL2dpdGh1Yi5jb20vdmlzaW9ubWVkaWEvY3NzLXBhcnNlL3B1bGwvNDkjaXNzdWVjb21tZW50LTMwMDg4MDI3XG52YXIgQ09NTUVOVF9SRUdFWCA9IC9cXC9cXCpbXipdKlxcKisoW14vKl1bXipdKlxcKispKlxcLy9nO1xuXG52YXIgTkVXTElORV9SRUdFWCA9IC9cXG4vZztcbnZhciBXSElURVNQQUNFX1JFR0VYID0gL15cXHMqLztcblxuLy8gZGVjbGFyYXRpb25cbnZhciBQUk9QRVJUWV9SRUdFWCA9IC9eKFxcKj9bLSMvKlxcXFxcXHddKyhcXFtbMC05YS16Xy1dK1xcXSk/KVxccyovO1xudmFyIENPTE9OX1JFR0VYID0gL146XFxzKi87XG52YXIgVkFMVUVfUkVHRVggPSAvXigoPzonKD86XFxcXCd8LikqPyd8XCIoPzpcXFxcXCJ8LikqP1wifFxcKFteKV0qP1xcKXxbXn07XSkrKS87XG52YXIgU0VNSUNPTE9OX1JFR0VYID0gL15bO1xcc10qLztcblxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL1RyaW0jUG9seWZpbGxcbnZhciBUUklNX1JFR0VYID0gL15cXHMrfFxccyskL2c7XG5cbi8vIHN0cmluZ3NcbnZhciBORVdMSU5FID0gJ1xcbic7XG52YXIgRk9SV0FSRF9TTEFTSCA9ICcvJztcbnZhciBBU1RFUklTSyA9ICcqJztcbnZhciBFTVBUWV9TVFJJTkcgPSAnJztcblxuLy8gdHlwZXNcbnZhciBUWVBFX0NPTU1FTlQgPSAnY29tbWVudCc7XG52YXIgVFlQRV9ERUNMQVJBVElPTiA9ICdkZWNsYXJhdGlvbic7XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0eWxlXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcmV0dXJuIHtPYmplY3RbXX1cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn1cbiAqIEB0aHJvd3Mge0Vycm9yfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHlsZSwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIHN0eWxlICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgfVxuXG4gIGlmICghc3R5bGUpIHJldHVybiBbXTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvKipcbiAgICogUG9zaXRpb25hbC5cbiAgICovXG4gIHZhciBsaW5lbm8gPSAxO1xuICB2YXIgY29sdW1uID0gMTtcblxuICAvKipcbiAgICogVXBkYXRlIGxpbmVubyBhbmQgY29sdW1uIGJhc2VkIG9uIGBzdHJgLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gICAqL1xuICBmdW5jdGlvbiB1cGRhdGVQb3NpdGlvbihzdHIpIHtcbiAgICB2YXIgbGluZXMgPSBzdHIubWF0Y2goTkVXTElORV9SRUdFWCk7XG4gICAgaWYgKGxpbmVzKSBsaW5lbm8gKz0gbGluZXMubGVuZ3RoO1xuICAgIHZhciBpID0gc3RyLmxhc3RJbmRleE9mKE5FV0xJTkUpO1xuICAgIGNvbHVtbiA9IH5pID8gc3RyLmxlbmd0aCAtIGkgOiBjb2x1bW4gKyBzdHIubGVuZ3RoO1xuICB9XG5cbiAgLyoqXG4gICAqIE1hcmsgcG9zaXRpb24gYW5kIHBhdGNoIGBub2RlLnBvc2l0aW9uYC5cbiAgICpcbiAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAqL1xuICBmdW5jdGlvbiBwb3NpdGlvbigpIHtcbiAgICB2YXIgc3RhcnQgPSB7IGxpbmU6IGxpbmVubywgY29sdW1uOiBjb2x1bW4gfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIG5vZGUucG9zaXRpb24gPSBuZXcgUG9zaXRpb24oc3RhcnQpO1xuICAgICAgd2hpdGVzcGFjZSgpO1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9yZSBwb3NpdGlvbiBpbmZvcm1hdGlvbiBmb3IgYSBub2RlLlxuICAgKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHByb3BlcnR5IHtPYmplY3R9IHN0YXJ0XG4gICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBlbmRcbiAgICogQHByb3BlcnR5IHt1bmRlZmluZWR8U3RyaW5nfSBzb3VyY2VcbiAgICovXG4gIGZ1bmN0aW9uIFBvc2l0aW9uKHN0YXJ0KSB7XG4gICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgIHRoaXMuZW5kID0geyBsaW5lOiBsaW5lbm8sIGNvbHVtbjogY29sdW1uIH07XG4gICAgdGhpcy5zb3VyY2UgPSBvcHRpb25zLnNvdXJjZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBOb24tZW51bWVyYWJsZSBzb3VyY2Ugc3RyaW5nLlxuICAgKi9cbiAgUG9zaXRpb24ucHJvdG90eXBlLmNvbnRlbnQgPSBzdHlsZTtcblxuICB2YXIgZXJyb3JzTGlzdCA9IFtdO1xuXG4gIC8qKlxuICAgKiBFcnJvciBgbXNnYC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1zZ1xuICAgKiBAdGhyb3dzIHtFcnJvcn1cbiAgICovXG4gIGZ1bmN0aW9uIGVycm9yKG1zZykge1xuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoXG4gICAgICBvcHRpb25zLnNvdXJjZSArICc6JyArIGxpbmVubyArICc6JyArIGNvbHVtbiArICc6ICcgKyBtc2dcbiAgICApO1xuICAgIGVyci5yZWFzb24gPSBtc2c7XG4gICAgZXJyLmZpbGVuYW1lID0gb3B0aW9ucy5zb3VyY2U7XG4gICAgZXJyLmxpbmUgPSBsaW5lbm87XG4gICAgZXJyLmNvbHVtbiA9IGNvbHVtbjtcbiAgICBlcnIuc291cmNlID0gc3R5bGU7XG5cbiAgICBpZiAob3B0aW9ucy5zaWxlbnQpIHtcbiAgICAgIGVycm9yc0xpc3QucHVzaChlcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1hdGNoIGByZWAgYW5kIHJldHVybiBjYXB0dXJlcy5cbiAgICpcbiAgICogQHBhcmFtIHtSZWdFeHB9IHJlXG4gICAqIEByZXR1cm4ge3VuZGVmaW5lZHxBcnJheX1cbiAgICovXG4gIGZ1bmN0aW9uIG1hdGNoKHJlKSB7XG4gICAgdmFyIG0gPSByZS5leGVjKHN0eWxlKTtcbiAgICBpZiAoIW0pIHJldHVybjtcbiAgICB2YXIgc3RyID0gbVswXTtcbiAgICB1cGRhdGVQb3NpdGlvbihzdHIpO1xuICAgIHN0eWxlID0gc3R5bGUuc2xpY2Uoc3RyLmxlbmd0aCk7XG4gICAgcmV0dXJuIG07XG4gIH1cblxuICAvKipcbiAgICogUGFyc2Ugd2hpdGVzcGFjZS5cbiAgICovXG4gIGZ1bmN0aW9uIHdoaXRlc3BhY2UoKSB7XG4gICAgbWF0Y2goV0hJVEVTUEFDRV9SRUdFWCk7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgY29tbWVudHMuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0W119IFtydWxlc11cbiAgICogQHJldHVybiB7T2JqZWN0W119XG4gICAqL1xuICBmdW5jdGlvbiBjb21tZW50cyhydWxlcykge1xuICAgIHZhciBjO1xuICAgIHJ1bGVzID0gcnVsZXMgfHwgW107XG4gICAgd2hpbGUgKChjID0gY29tbWVudCgpKSkge1xuICAgICAgaWYgKGMgIT09IGZhbHNlKSB7XG4gICAgICAgIHJ1bGVzLnB1c2goYyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBydWxlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBjb21tZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqIEB0aHJvd3Mge0Vycm9yfVxuICAgKi9cbiAgZnVuY3Rpb24gY29tbWVudCgpIHtcbiAgICB2YXIgcG9zID0gcG9zaXRpb24oKTtcbiAgICBpZiAoRk9SV0FSRF9TTEFTSCAhPSBzdHlsZS5jaGFyQXQoMCkgfHwgQVNURVJJU0sgIT0gc3R5bGUuY2hhckF0KDEpKSByZXR1cm47XG5cbiAgICB2YXIgaSA9IDI7XG4gICAgd2hpbGUgKFxuICAgICAgRU1QVFlfU1RSSU5HICE9IHN0eWxlLmNoYXJBdChpKSAmJlxuICAgICAgKEFTVEVSSVNLICE9IHN0eWxlLmNoYXJBdChpKSB8fCBGT1JXQVJEX1NMQVNIICE9IHN0eWxlLmNoYXJBdChpICsgMSkpXG4gICAgKSB7XG4gICAgICArK2k7XG4gICAgfVxuICAgIGkgKz0gMjtcblxuICAgIGlmIChFTVBUWV9TVFJJTkcgPT09IHN0eWxlLmNoYXJBdChpIC0gMSkpIHtcbiAgICAgIHJldHVybiBlcnJvcignRW5kIG9mIGNvbW1lbnQgbWlzc2luZycpO1xuICAgIH1cblxuICAgIHZhciBzdHIgPSBzdHlsZS5zbGljZSgyLCBpIC0gMik7XG4gICAgY29sdW1uICs9IDI7XG4gICAgdXBkYXRlUG9zaXRpb24oc3RyKTtcbiAgICBzdHlsZSA9IHN0eWxlLnNsaWNlKGkpO1xuICAgIGNvbHVtbiArPSAyO1xuXG4gICAgcmV0dXJuIHBvcyh7XG4gICAgICB0eXBlOiBUWVBFX0NPTU1FTlQsXG4gICAgICBjb21tZW50OiBzdHJcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBkZWNsYXJhdGlvbi5cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiBAdGhyb3dzIHtFcnJvcn1cbiAgICovXG4gIGZ1bmN0aW9uIGRlY2xhcmF0aW9uKCkge1xuICAgIHZhciBwb3MgPSBwb3NpdGlvbigpO1xuXG4gICAgLy8gcHJvcFxuICAgIHZhciBwcm9wID0gbWF0Y2goUFJPUEVSVFlfUkVHRVgpO1xuICAgIGlmICghcHJvcCkgcmV0dXJuO1xuICAgIGNvbW1lbnQoKTtcblxuICAgIC8vIDpcbiAgICBpZiAoIW1hdGNoKENPTE9OX1JFR0VYKSkgcmV0dXJuIGVycm9yKFwicHJvcGVydHkgbWlzc2luZyAnOidcIik7XG5cbiAgICAvLyB2YWxcbiAgICB2YXIgdmFsID0gbWF0Y2goVkFMVUVfUkVHRVgpO1xuXG4gICAgdmFyIHJldCA9IHBvcyh7XG4gICAgICB0eXBlOiBUWVBFX0RFQ0xBUkFUSU9OLFxuICAgICAgcHJvcGVydHk6IHRyaW0ocHJvcFswXS5yZXBsYWNlKENPTU1FTlRfUkVHRVgsIEVNUFRZX1NUUklORykpLFxuICAgICAgdmFsdWU6IHZhbFxuICAgICAgICA/IHRyaW0odmFsWzBdLnJlcGxhY2UoQ09NTUVOVF9SRUdFWCwgRU1QVFlfU1RSSU5HKSlcbiAgICAgICAgOiBFTVBUWV9TVFJJTkdcbiAgICB9KTtcblxuICAgIC8vIDtcbiAgICBtYXRjaChTRU1JQ09MT05fUkVHRVgpO1xuXG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBkZWNsYXJhdGlvbnMuXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdFtdfVxuICAgKi9cbiAgZnVuY3Rpb24gZGVjbGFyYXRpb25zKCkge1xuICAgIHZhciBkZWNscyA9IFtdO1xuXG4gICAgY29tbWVudHMoZGVjbHMpO1xuXG4gICAgLy8gZGVjbGFyYXRpb25zXG4gICAgdmFyIGRlY2w7XG4gICAgd2hpbGUgKChkZWNsID0gZGVjbGFyYXRpb24oKSkpIHtcbiAgICAgIGlmIChkZWNsICE9PSBmYWxzZSkge1xuICAgICAgICBkZWNscy5wdXNoKGRlY2wpO1xuICAgICAgICBjb21tZW50cyhkZWNscyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlY2xzO1xuICB9XG5cbiAgd2hpdGVzcGFjZSgpO1xuICByZXR1cm4gZGVjbGFyYXRpb25zKCk7XG59O1xuXG4vKipcbiAqIFRyaW0gYHN0cmAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiB0cmltKHN0cikge1xuICByZXR1cm4gc3RyID8gc3RyLnJlcGxhY2UoVFJJTV9SRUdFWCwgRU1QVFlfU1RSSU5HKSA6IEVNUFRZX1NUUklORztcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/hast-util-to-jsx-runtime/node_modules/inline-style-parser/index.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/hast-util-to-jsx-runtime/node_modules/style-to-object/cjs/index.js":
/*!******************************************************************************************!*\
  !*** ../node_modules/hast-util-to-jsx-runtime/node_modules/style-to-object/cjs/index.js ***!
  \******************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports[\"default\"] = StyleToObject;\nvar inline_style_parser_1 = __importDefault(__webpack_require__(/*! inline-style-parser */ \"(rsc)/../node_modules/hast-util-to-jsx-runtime/node_modules/inline-style-parser/index.js\"));\n/**\n * Parses inline style to object.\n *\n * @param style - Inline style.\n * @param iterator - Iterator.\n * @returns - Style object or null.\n *\n * @example Parsing inline style to object:\n *\n * ```js\n * import parse from 'style-to-object';\n * parse('line-height: 42;'); // { 'line-height': '42' }\n * ```\n */\nfunction StyleToObject(style, iterator) {\n    var styleObject = null;\n    if (!style || typeof style !== 'string') {\n        return styleObject;\n    }\n    var declarations = (0, inline_style_parser_1.default)(style);\n    var hasIterator = typeof iterator === 'function';\n    declarations.forEach(function (declaration) {\n        if (declaration.type !== 'declaration') {\n            return;\n        }\n        var property = declaration.property, value = declaration.value;\n        if (hasIterator) {\n            iterator(property, value, declaration);\n        }\n        else if (value) {\n            styleObject = styleObject || {};\n            styleObject[property] = value;\n        }\n    });\n    return styleObject;\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2hhc3QtdXRpbC10by1qc3gtcnVudGltZS9ub2RlX21vZHVsZXMvc3R5bGUtdG8tb2JqZWN0L2Nqcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFlO0FBQ2YsNENBQTRDLG1CQUFPLENBQUMscUhBQXFCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsSUFBSSxLQUFLO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9naXRodWJfbXlfcG9ydGZvbGlvLy4uL25vZGVfbW9kdWxlcy9oYXN0LXV0aWwtdG8tanN4LXJ1bnRpbWUvbm9kZV9tb2R1bGVzL3N0eWxlLXRvLW9iamVjdC9janMvaW5kZXguanM/NTk0OCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IFN0eWxlVG9PYmplY3Q7XG52YXIgaW5saW5lX3N0eWxlX3BhcnNlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJpbmxpbmUtc3R5bGUtcGFyc2VyXCIpKTtcbi8qKlxuICogUGFyc2VzIGlubGluZSBzdHlsZSB0byBvYmplY3QuXG4gKlxuICogQHBhcmFtIHN0eWxlIC0gSW5saW5lIHN0eWxlLlxuICogQHBhcmFtIGl0ZXJhdG9yIC0gSXRlcmF0b3IuXG4gKiBAcmV0dXJucyAtIFN0eWxlIG9iamVjdCBvciBudWxsLlxuICpcbiAqIEBleGFtcGxlIFBhcnNpbmcgaW5saW5lIHN0eWxlIHRvIG9iamVjdDpcbiAqXG4gKiBgYGBqc1xuICogaW1wb3J0IHBhcnNlIGZyb20gJ3N0eWxlLXRvLW9iamVjdCc7XG4gKiBwYXJzZSgnbGluZS1oZWlnaHQ6IDQyOycpOyAvLyB7ICdsaW5lLWhlaWdodCc6ICc0MicgfVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIFN0eWxlVG9PYmplY3Qoc3R5bGUsIGl0ZXJhdG9yKSB7XG4gICAgdmFyIHN0eWxlT2JqZWN0ID0gbnVsbDtcbiAgICBpZiAoIXN0eWxlIHx8IHR5cGVvZiBzdHlsZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHN0eWxlT2JqZWN0O1xuICAgIH1cbiAgICB2YXIgZGVjbGFyYXRpb25zID0gKDAsIGlubGluZV9zdHlsZV9wYXJzZXJfMS5kZWZhdWx0KShzdHlsZSk7XG4gICAgdmFyIGhhc0l0ZXJhdG9yID0gdHlwZW9mIGl0ZXJhdG9yID09PSAnZnVuY3Rpb24nO1xuICAgIGRlY2xhcmF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChkZWNsYXJhdGlvbikge1xuICAgICAgICBpZiAoZGVjbGFyYXRpb24udHlwZSAhPT0gJ2RlY2xhcmF0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcm9wZXJ0eSA9IGRlY2xhcmF0aW9uLnByb3BlcnR5LCB2YWx1ZSA9IGRlY2xhcmF0aW9uLnZhbHVlO1xuICAgICAgICBpZiAoaGFzSXRlcmF0b3IpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKHByb3BlcnR5LCB2YWx1ZSwgZGVjbGFyYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBzdHlsZU9iamVjdCA9IHN0eWxlT2JqZWN0IHx8IHt9O1xuICAgICAgICAgICAgc3R5bGVPYmplY3RbcHJvcGVydHldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gc3R5bGVPYmplY3Q7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/hast-util-to-jsx-runtime/node_modules/style-to-object/cjs/index.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/hast-util-to-jsx-runtime/lib/index.js":
/*!*************************************************************!*\
  !*** ../node_modules/hast-util-to-jsx-runtime/lib/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   toJsxRuntime: () => (/* binding */ toJsxRuntime)\n/* harmony export */ });\n/* harmony import */ var comma_separated_tokens__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! comma-separated-tokens */ \"(ssr)/../node_modules/comma-separated-tokens/index.js\");\n/* harmony import */ var devlop__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! devlop */ \"(ssr)/../node_modules/devlop/lib/development.js\");\n/* harmony import */ var estree_util_is_identifier_name__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! estree-util-is-identifier-name */ \"(ssr)/../node_modules/estree-util-is-identifier-name/lib/index.js\");\n/* harmony import */ var hast_util_whitespace__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! hast-util-whitespace */ \"(ssr)/../node_modules/hast-util-whitespace/lib/index.js\");\n/* harmony import */ var property_information__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! property-information */ \"(ssr)/../node_modules/property-information/index.js\");\n/* harmony import */ var property_information__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! property-information */ \"(ssr)/../node_modules/property-information/lib/find.js\");\n/* harmony import */ var property_information__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! property-information */ \"(ssr)/../node_modules/property-information/lib/hast-to-react.js\");\n/* harmony import */ var space_separated_tokens__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! space-separated-tokens */ \"(ssr)/../node_modules/space-separated-tokens/index.js\");\n/* harmony import */ var style_to_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! style-to-object */ \"(ssr)/../node_modules/hast-util-to-jsx-runtime/node_modules/style-to-object/esm/index.mjs\");\n/* harmony import */ var unist_util_position__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! unist-util-position */ \"(ssr)/../node_modules/unist-util-position/lib/index.js\");\n/* harmony import */ var vfile_message__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! vfile-message */ \"(ssr)/../node_modules/vfile-message/lib/index.js\");\n// Register MDX nodes in mdast:\n/// <reference types=\"mdast-util-mdx-expression\" />\n/// <reference types=\"mdast-util-mdx-jsx\" />\n/// <reference types=\"mdast-util-mdxjs-esm\" />\n\n/**\n * @typedef {import('estree').Identifier} Identifier\n * @typedef {import('estree').Literal} Literal\n * @typedef {import('estree').MemberExpression} MemberExpression\n * @typedef {import('estree').Expression} Expression\n * @typedef {import('estree').Program} Program\n *\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Nodes} Nodes\n * @typedef {import('hast').Parents} Parents\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Text} Text\n *\n * @typedef {import('mdast-util-mdx-expression').MdxFlowExpressionHast} MdxFlowExpression\n * @typedef {import('mdast-util-mdx-expression').MdxTextExpressionHast} MdxTextExpression\n *\n * @typedef {import('mdast-util-mdx-jsx').MdxJsxFlowElementHast} MdxJsxFlowElement\n * @typedef {import('mdast-util-mdx-jsx').MdxJsxTextElementHast} MdxJsxTextElement\n *\n * @typedef {import('mdast-util-mdxjs-esm').MdxjsEsmHast} MdxjsEsm\n *\n * @typedef {import('property-information').Schema} Schema\n *\n * @typedef {import('unist').Position} Position\n *\n * @typedef {import('./components.js').Components} Components\n */\n\n/**\n * @typedef {JSX.Element | string | null | undefined} Child\n *   Child.\n *\n * @callback Create\n *   Create something in development or production.\n * @param {Nodes} node\n *   hast node.\n * @param {unknown} type\n *   Fragment symbol or tag name.\n * @param {Props} props\n *   Properties and children.\n * @param {string | undefined} key\n *   Key.\n * @returns {JSX.Element}\n *   Result.\n *\n * @callback CreateEvaluater\n *   Create an evaluator that turns ESTree ASTs from embedded MDX into values.\n * @returns {Evaluater}\n *   Evaluater.\n *\n * @typedef {'html' | 'react'} ElementAttributeNameCase\n *   Casing to use for attribute names.\n *\n *   HTML casing is for example `class`, `stroke-linecap`, `xml:lang`.\n *   React casing is for example `className`, `strokeLinecap`, `xmlLang`.\n *\n * @callback EvaluateExpression\n *   Turn an MDX expression into a value.\n * @param {Expression} expression\n *   ESTree expression.\n * @returns {unknown}\n *   Result of expression.\n *\n * @callback EvaluateProgram\n *   Turn an MDX program (export/import statements) into a value.\n * @param {Program} expression\n *   ESTree program.\n * @returns {unknown}\n *   Result of program;\n *   should likely be `undefined` as ESM changes the scope but doesnâ€™t yield\n *   something.\n *\n * @typedef Evaluater\n *   Evaluator that turns ESTree ASTs from embedded MDX into values.\n * @property {EvaluateExpression} evaluateExpression\n *   Evaluate an expression.\n * @property {EvaluateProgram} evaluateProgram\n *   Evaluate a program.\n *\n * @typedef {[string, Value]} Field\n *   Property field.\n *\n * @typedef {unknown} Fragment\n *   Represent the children, typically a symbol.\n *\n * @callback Jsx\n *   Create a production element.\n * @param {unknown} type\n *   Element type: `Fragment` symbol, tag name (`string`), component.\n * @param {Props} props\n *   Element props, `children`, and maybe `node`.\n * @param {string | undefined} [key]\n *   Dynamicly generated key to use.\n * @returns {JSX.Element}\n *   Element from your framework.\n *\n * @callback JsxDev\n *   Create a development element.\n * @param {unknown} type\n *   Element type: `Fragment` symbol, tag name (`string`), component.\n * @param {Props} props\n *   Element props, `children`, and maybe `node`.\n * @param {string | undefined} key\n *   Dynamicly generated key to use.\n * @param {boolean} isStaticChildren\n *   Whether two or more children are passed (in an array), which is whether\n *   `jsxs` or `jsx` would be used.\n * @param {Source} source\n *   Info about source.\n * @param {undefined} self\n *   Nothing (this is used by frameworks that have components, we donâ€™t).\n * @returns {JSX.Element}\n *   Element from your framework.\n *\n * @typedef {{children?: Array<Child> | Child, node?: Element | MdxJsxFlowElement | MdxJsxTextElement | undefined, [prop: string]: Array<Child> | Child | Element | MdxJsxFlowElement | MdxJsxTextElement | Value | undefined}} Props\n *   Properties and children.\n *\n * @typedef RegularFields\n *   Configuration.\n * @property {Partial<Components> | null | undefined} [components]\n *   Components to use (optional).\n * @property {CreateEvaluater | null | undefined} [createEvaluater]\n *   Create an evaluator that turns ESTree ASTs into values (optional).\n * @property {ElementAttributeNameCase | null | undefined} [elementAttributeNameCase='react']\n *   Specify casing to use for attribute names (default: `'react'`).\n * @property {string | null | undefined} [filePath]\n *   File path to the original source file (optional).\n *\n *   Passed in source info to `jsxDEV` when using the automatic runtime with\n *   `development: true`.\n * @property {boolean | null | undefined} [ignoreInvalidStyle=false]\n *   Ignore invalid CSS in `style` props (default: `false`);\n *   the default behavior is to throw an error.\n * @property {boolean | null | undefined} [passKeys=true]\n *   Generate keys to optimize frameworks that support them (default: `true`).\n *\n *   > ðŸ‘‰ **Note**: Solid currently fails if keys are passed.\n * @property {boolean | null | undefined} [passNode=false]\n *   Pass the hast element node to components (default: `false`).\n * @property {Space | null | undefined} [space='html']\n *   Whether `tree` is in the `'html'` or `'svg'` space (default: `'html'`).\n *\n *   When an `<svg>` element is found in the HTML space, this package already\n *   automatically switches to and from the SVG space when entering and exiting\n *   it.\n * @property {StylePropertyNameCase | null | undefined} [stylePropertyNameCase='dom']\n *   Specify casing to use for property names in `style` objects (default:\n *   `'dom'`).\n * @property {boolean | null | undefined} [tableCellAlignToStyle=true]\n *   Turn obsolete `align` props on `td` and `th` into CSS `style` props\n *   (default: `true`).\n *\n * @typedef RuntimeDevelopment\n *   Runtime fields when development is on.\n * @property {Fragment} Fragment\n *   Fragment.\n * @property {true} development\n *   Whether to use `jsxDEV` (when on) or `jsx` and `jsxs` (when off).\n * @property {Jsx | null | undefined} [jsx]\n *   Dynamic JSX (optional).\n * @property {JsxDev} jsxDEV\n *   Development JSX.\n * @property {Jsx | null | undefined} [jsxs]\n *   Static JSX (optional).\n *\n * @typedef RuntimeProduction\n *   Runtime fields when development is off.\n * @property {Fragment} Fragment\n *   Fragment.\n * @property {false | null | undefined} [development]\n *   Whether to use `jsxDEV` (when on) or `jsx` and `jsxs` (when off) (optional).\n * @property {Jsx} jsx\n *   Dynamic JSX.\n * @property {JsxDev | null | undefined} [jsxDEV]\n *   Development JSX (optional).\n * @property {Jsx} jsxs\n *   Static JSX.\n *\n * @typedef RuntimeUnknown\n *   Runtime fields when development might be on or off.\n * @property {Fragment} Fragment\n *   Fragment.\n * @property {boolean} development\n *   Whether to use `jsxDEV` (when on) or `jsx` and `jsxs` (when off).\n * @property {Jsx | null | undefined} [jsx]\n *   Dynamic JSX (optional).\n * @property {JsxDev | null | undefined} [jsxDEV]\n *   Development JSX (optional).\n * @property {Jsx | null | undefined} [jsxs]\n *   Static JSX (optional).\n *\n * @typedef Source\n *   Info about source.\n * @property {number | undefined} columnNumber\n *   Column where thing starts (0-indexed).\n * @property {string | undefined} fileName\n *   Name of source file.\n * @property {number | undefined} lineNumber\n *   Line where thing starts (1-indexed).\n *\n * @typedef {'html' | 'svg'} Space\n *   Namespace.\n *\n *   > ðŸ‘‰ **Note**: hast is not XML.\n *   > It supports SVG as embedded in HTML.\n *   > It does not support the features available in XML.\n *   > Passing SVG might break but fragments of modern SVG should be fine.\n *   > Use `xast` if you need to support SVG as XML.\n *\n * @typedef State\n *   Info passed around.\n * @property {unknown} Fragment\n *   Fragment symbol.\n * @property {Array<Parents>} ancestors\n *   Stack of parents.\n * @property {Partial<Components>} components\n *   Components to swap.\n * @property {Create} create\n *   Create something in development or production.\n * @property {ElementAttributeNameCase} elementAttributeNameCase\n *   Casing to use for attribute names.\n * @property {Evaluater | undefined} evaluater\n *   Evaluator that turns ESTree ASTs into values.\n * @property {string | undefined} filePath\n *   File path.\n * @property {boolean} ignoreInvalidStyle\n *   Ignore invalid CSS in `style` props.\n * @property {boolean} passKeys\n *   Generate keys to optimize frameworks that support them.\n * @property {boolean} passNode\n *   Pass `node` to components.\n * @property {Schema} schema\n *   Current schema.\n * @property {StylePropertyNameCase} stylePropertyNameCase\n *   Casing to use for property names in `style` objects.\n * @property {boolean} tableCellAlignToStyle\n *   Turn obsolete `align` props on `td` and `th` into CSS `style` props.\n *\n * @typedef {Record<string, string>} Style\n *   Style map.\n *\n * @typedef {'css' | 'dom'} StylePropertyNameCase\n *   Casing to use for property names in `style` objects.\n *\n *   CSS casing is for example `background-color` and `-webkit-line-clamp`.\n *   DOM casing is for example `backgroundColor` and `WebkitLineClamp`.\n *\n * @typedef {Style | boolean | number | string} Value\n *   Primitive property value and `Style` map.\n */\n\n/**\n * @typedef {RuntimeDevelopment & RegularFields} Development\n *   Configuration (development).\n * @typedef {Development | Production | Unknown} Options\n *   Configuration.\n * @typedef {RegularFields & RuntimeProduction} Production\n *   Configuration (production).\n * @typedef {RegularFields & RuntimeUnknown} Unknown\n *   Configuration (production or development).\n */\n\n\n\n\n\n\n\n\n\n\n\nconst own = {}.hasOwnProperty\n\n/** @type {Map<string, number>} */\nconst emptyMap = new Map()\n\nconst cap = /[A-Z]/g\nconst dashSomething = /-([a-z])/g\n\n// `react-dom` triggers a warning for *any* white space in tables.\n// To follow GFM, `mdast-util-to-hast` injects line endings between elements.\n// Other tools might do so too, but they donâ€™t do here, so we remove all of\n// that.\n\n// See: <https://github.com/facebook/react/pull/7081>.\n// See: <https://github.com/facebook/react/pull/7515>.\n// See: <https://github.com/remarkjs/remark-react/issues/64>.\n// See: <https://github.com/rehypejs/rehype-react/pull/29>.\n// See: <https://github.com/rehypejs/rehype-react/pull/32>.\n// See: <https://github.com/rehypejs/rehype-react/pull/45>.\nconst tableElements = new Set(['table', 'tbody', 'thead', 'tfoot', 'tr'])\n\nconst tableCellElement = new Set(['td', 'th'])\n\nconst docs = 'https://github.com/syntax-tree/hast-util-to-jsx-runtime'\n\n/**\n * Transform a hast tree to preact, react, solid, svelte, vue, etc.,\n * with an automatic JSX runtime.\n *\n * @param {Nodes} tree\n *   Tree to transform.\n * @param {Options} options\n *   Configuration (required).\n * @returns {JSX.Element}\n *   JSX element.\n */\n\nfunction toJsxRuntime(tree, options) {\n  if (!options || options.Fragment === undefined) {\n    throw new TypeError('Expected `Fragment` in options')\n  }\n\n  const filePath = options.filePath || undefined\n  /** @type {Create} */\n  let create\n\n  if (options.development) {\n    if (typeof options.jsxDEV !== 'function') {\n      throw new TypeError(\n        'Expected `jsxDEV` in options when `development: true`'\n      )\n    }\n\n    create = developmentCreate(filePath, options.jsxDEV)\n  } else {\n    if (typeof options.jsx !== 'function') {\n      throw new TypeError('Expected `jsx` in production options')\n    }\n\n    if (typeof options.jsxs !== 'function') {\n      throw new TypeError('Expected `jsxs` in production options')\n    }\n\n    create = productionCreate(filePath, options.jsx, options.jsxs)\n  }\n\n  /** @type {State} */\n  const state = {\n    Fragment: options.Fragment,\n    ancestors: [],\n    components: options.components || {},\n    create,\n    elementAttributeNameCase: options.elementAttributeNameCase || 'react',\n    evaluater: options.createEvaluater ? options.createEvaluater() : undefined,\n    filePath,\n    ignoreInvalidStyle: options.ignoreInvalidStyle || false,\n    passKeys: options.passKeys !== false,\n    passNode: options.passNode || false,\n    schema: options.space === 'svg' ? property_information__WEBPACK_IMPORTED_MODULE_1__.svg : property_information__WEBPACK_IMPORTED_MODULE_1__.html,\n    stylePropertyNameCase: options.stylePropertyNameCase || 'dom',\n    tableCellAlignToStyle: options.tableCellAlignToStyle !== false\n  }\n\n  const result = one(state, tree, undefined)\n\n  // JSX element.\n  if (result && typeof result !== 'string') {\n    return result\n  }\n\n  // Text node or something that turned into nothing.\n  return state.create(\n    tree,\n    state.Fragment,\n    {children: result || undefined},\n    undefined\n  )\n}\n\n/**\n * Transform a node.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Nodes} node\n *   Current node.\n * @param {string | undefined} key\n *   Key.\n * @returns {Child | undefined}\n *   Child, optional.\n */\nfunction one(state, node, key) {\n  if (node.type === 'element') {\n    return element(state, node, key)\n  }\n\n  if (node.type === 'mdxFlowExpression' || node.type === 'mdxTextExpression') {\n    return mdxExpression(state, node)\n  }\n\n  if (node.type === 'mdxJsxFlowElement' || node.type === 'mdxJsxTextElement') {\n    return mdxJsxElement(state, node, key)\n  }\n\n  if (node.type === 'mdxjsEsm') {\n    return mdxEsm(state, node)\n  }\n\n  if (node.type === 'root') {\n    return root(state, node, key)\n  }\n\n  if (node.type === 'text') {\n    return text(state, node)\n  }\n}\n\n/**\n * Handle element.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Element} node\n *   Current node.\n * @param {string | undefined} key\n *   Key.\n * @returns {Child | undefined}\n *   Child, optional.\n */\nfunction element(state, node, key) {\n  const parentSchema = state.schema\n  let schema = parentSchema\n\n  if (node.tagName.toLowerCase() === 'svg' && parentSchema.space === 'html') {\n    schema = property_information__WEBPACK_IMPORTED_MODULE_1__.svg\n    state.schema = schema\n  }\n\n  state.ancestors.push(node)\n\n  const type = findComponentFromName(state, node.tagName, false)\n  const props = createElementProps(state, node)\n  let children = createChildren(state, node)\n\n  if (tableElements.has(node.tagName)) {\n    children = children.filter(function (child) {\n      return typeof child === 'string' ? !(0,hast_util_whitespace__WEBPACK_IMPORTED_MODULE_2__.whitespace)(child) : true\n    })\n  }\n\n  addNode(state, props, type, node)\n  addChildren(props, children)\n\n  // Restore.\n  state.ancestors.pop()\n  state.schema = parentSchema\n\n  return state.create(node, type, props, key)\n}\n\n/**\n * Handle MDX expression.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdxFlowExpression | MdxTextExpression} node\n *   Current node.\n * @returns {Child | undefined}\n *   Child, optional.\n */\nfunction mdxExpression(state, node) {\n  if (node.data && node.data.estree && state.evaluater) {\n    const program = node.data.estree\n    const expression = program.body[0]\n    ;(0,devlop__WEBPACK_IMPORTED_MODULE_3__.ok)(expression.type === 'ExpressionStatement')\n\n    // Assume result is a child.\n    return /** @type {Child | undefined} */ (\n      state.evaluater.evaluateExpression(expression.expression)\n    )\n  }\n\n  crashEstree(state, node.position)\n}\n\n/**\n * Handle MDX ESM.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdxjsEsm} node\n *   Current node.\n * @returns {Child | undefined}\n *   Child, optional.\n */\nfunction mdxEsm(state, node) {\n  if (node.data && node.data.estree && state.evaluater) {\n    // Assume result is a child.\n    return /** @type {Child | undefined} */ (\n      state.evaluater.evaluateProgram(node.data.estree)\n    )\n  }\n\n  crashEstree(state, node.position)\n}\n\n/**\n * Handle MDX JSX.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdxJsxFlowElement | MdxJsxTextElement} node\n *   Current node.\n * @param {string | undefined} key\n *   Key.\n * @returns {Child | undefined}\n *   Child, optional.\n */\nfunction mdxJsxElement(state, node, key) {\n  const parentSchema = state.schema\n  let schema = parentSchema\n\n  if (node.name === 'svg' && parentSchema.space === 'html') {\n    schema = property_information__WEBPACK_IMPORTED_MODULE_1__.svg\n    state.schema = schema\n  }\n\n  state.ancestors.push(node)\n\n  const type =\n    node.name === null\n      ? state.Fragment\n      : findComponentFromName(state, node.name, true)\n  const props = createJsxElementProps(state, node)\n  const children = createChildren(state, node)\n\n  addNode(state, props, type, node)\n  addChildren(props, children)\n\n  // Restore.\n  state.ancestors.pop()\n  state.schema = parentSchema\n\n  return state.create(node, type, props, key)\n}\n\n/**\n * Handle root.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Root} node\n *   Current node.\n * @param {string | undefined} key\n *   Key.\n * @returns {Child | undefined}\n *   Child, optional.\n */\nfunction root(state, node, key) {\n  /** @type {Props} */\n  const props = {}\n\n  addChildren(props, createChildren(state, node))\n\n  return state.create(node, state.Fragment, props, key)\n}\n\n/**\n * Handle text.\n *\n * @param {State} _\n *   Info passed around.\n * @param {Text} node\n *   Current node.\n * @returns {Child | undefined}\n *   Child, optional.\n */\nfunction text(_, node) {\n  return node.value\n}\n\n/**\n * Add `node` to props.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Props} props\n *   Props.\n * @param {unknown} type\n *   Type.\n * @param {Element | MdxJsxFlowElement | MdxJsxTextElement} node\n *   Node.\n * @returns {undefined}\n *   Nothing.\n */\nfunction addNode(state, props, type, node) {\n  // If this is swapped out for a component:\n  if (typeof type !== 'string' && type !== state.Fragment && state.passNode) {\n    props.node = node\n  }\n}\n\n/**\n * Add children to props.\n *\n * @param {Props} props\n *   Props.\n * @param {Array<Child>} children\n *   Children.\n * @returns {undefined}\n *   Nothing.\n */\nfunction addChildren(props, children) {\n  if (children.length > 0) {\n    const value = children.length > 1 ? children : children[0]\n\n    if (value) {\n      props.children = value\n    }\n  }\n}\n\n/**\n * @param {string | undefined} _\n *   Path to file.\n * @param {Jsx} jsx\n *   Dynamic.\n * @param {Jsx} jsxs\n *   Static.\n * @returns {Create}\n *   Create a production element.\n */\nfunction productionCreate(_, jsx, jsxs) {\n  return create\n  /** @type {Create} */\n  function create(_, type, props, key) {\n    // Only an array when there are 2 or more children.\n    const isStaticChildren = Array.isArray(props.children)\n    const fn = isStaticChildren ? jsxs : jsx\n    return key ? fn(type, props, key) : fn(type, props)\n  }\n}\n\n/**\n * @param {string | undefined} filePath\n *   Path to file.\n * @param {JsxDev} jsxDEV\n *   Development.\n * @returns {Create}\n *   Create a development element.\n */\nfunction developmentCreate(filePath, jsxDEV) {\n  return create\n  /** @type {Create} */\n  function create(node, type, props, key) {\n    // Only an array when there are 2 or more children.\n    const isStaticChildren = Array.isArray(props.children)\n    const point = (0,unist_util_position__WEBPACK_IMPORTED_MODULE_4__.pointStart)(node)\n    return jsxDEV(\n      type,\n      props,\n      key,\n      isStaticChildren,\n      {\n        columnNumber: point ? point.column - 1 : undefined,\n        fileName: filePath,\n        lineNumber: point ? point.line : undefined\n      },\n      undefined\n    )\n  }\n}\n\n/**\n * Create props from an element.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Element} node\n *   Current element.\n * @returns {Props}\n *   Props.\n */\nfunction createElementProps(state, node) {\n  /** @type {Props} */\n  const props = {}\n  /** @type {string | undefined} */\n  let alignValue\n  /** @type {string} */\n  let prop\n\n  for (prop in node.properties) {\n    if (prop !== 'children' && own.call(node.properties, prop)) {\n      const result = createProperty(state, prop, node.properties[prop])\n\n      if (result) {\n        const [key, value] = result\n\n        if (\n          state.tableCellAlignToStyle &&\n          key === 'align' &&\n          typeof value === 'string' &&\n          tableCellElement.has(node.tagName)\n        ) {\n          alignValue = value\n        } else {\n          props[key] = value\n        }\n      }\n    }\n  }\n\n  if (alignValue) {\n    // Assume style is an object.\n    const style = /** @type {Style} */ (props.style || (props.style = {}))\n    style[state.stylePropertyNameCase === 'css' ? 'text-align' : 'textAlign'] =\n      alignValue\n  }\n\n  return props\n}\n\n/**\n * Create props from a JSX element.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdxJsxFlowElement | MdxJsxTextElement} node\n *   Current JSX element.\n * @returns {Props}\n *   Props.\n */\nfunction createJsxElementProps(state, node) {\n  /** @type {Props} */\n  const props = {}\n\n  for (const attribute of node.attributes) {\n    if (attribute.type === 'mdxJsxExpressionAttribute') {\n      if (attribute.data && attribute.data.estree && state.evaluater) {\n        const program = attribute.data.estree\n        const expression = program.body[0]\n        ;(0,devlop__WEBPACK_IMPORTED_MODULE_3__.ok)(expression.type === 'ExpressionStatement')\n        const objectExpression = expression.expression\n        ;(0,devlop__WEBPACK_IMPORTED_MODULE_3__.ok)(objectExpression.type === 'ObjectExpression')\n        const property = objectExpression.properties[0]\n        ;(0,devlop__WEBPACK_IMPORTED_MODULE_3__.ok)(property.type === 'SpreadElement')\n\n        Object.assign(\n          props,\n          state.evaluater.evaluateExpression(property.argument)\n        )\n      } else {\n        crashEstree(state, node.position)\n      }\n    } else {\n      // For JSX, the author is responsible of passing in the correct values.\n      const name = attribute.name\n      /** @type {unknown} */\n      let value\n\n      if (attribute.value && typeof attribute.value === 'object') {\n        if (\n          attribute.value.data &&\n          attribute.value.data.estree &&\n          state.evaluater\n        ) {\n          const program = attribute.value.data.estree\n          const expression = program.body[0]\n          ;(0,devlop__WEBPACK_IMPORTED_MODULE_3__.ok)(expression.type === 'ExpressionStatement')\n          value = state.evaluater.evaluateExpression(expression.expression)\n        } else {\n          crashEstree(state, node.position)\n        }\n      } else {\n        value = attribute.value === null ? true : attribute.value\n      }\n\n      // Assume a prop.\n      props[name] = /** @type {Props[keyof Props]} */ (value)\n    }\n  }\n\n  return props\n}\n\n/**\n * Create children.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Parents} node\n *   Current element.\n * @returns {Array<Child>}\n *   Children.\n */\nfunction createChildren(state, node) {\n  /** @type {Array<Child>} */\n  const children = []\n  let index = -1\n  /** @type {Map<string, number>} */\n  // Note: test this when Solid doesnâ€™t want to merge my upcoming PR.\n  /* c8 ignore next */\n  const countsByName = state.passKeys ? new Map() : emptyMap\n\n  while (++index < node.children.length) {\n    const child = node.children[index]\n    /** @type {string | undefined} */\n    let key\n\n    if (state.passKeys) {\n      const name =\n        child.type === 'element'\n          ? child.tagName\n          : child.type === 'mdxJsxFlowElement' ||\n              child.type === 'mdxJsxTextElement'\n            ? child.name\n            : undefined\n\n      if (name) {\n        const count = countsByName.get(name) || 0\n        key = name + '-' + count\n        countsByName.set(name, count + 1)\n      }\n    }\n\n    const result = one(state, child, key)\n    if (result !== undefined) children.push(result)\n  }\n\n  return children\n}\n\n/**\n * Handle a property.\n *\n * @param {State} state\n *   Info passed around.\n * @param {string} prop\n *   Key.\n * @param {Array<number | string> | boolean | number | string | null | undefined} value\n *   hast property value.\n * @returns {Field | undefined}\n *   Field for runtime, optional.\n */\nfunction createProperty(state, prop, value) {\n  const info = (0,property_information__WEBPACK_IMPORTED_MODULE_5__.find)(state.schema, prop)\n\n  // Ignore nullish and `NaN` values.\n  if (\n    value === null ||\n    value === undefined ||\n    (typeof value === 'number' && Number.isNaN(value))\n  ) {\n    return\n  }\n\n  if (Array.isArray(value)) {\n    // Accept `array`.\n    // Most props are space-separated.\n    value = info.commaSeparated ? (0,comma_separated_tokens__WEBPACK_IMPORTED_MODULE_6__.stringify)(value) : (0,space_separated_tokens__WEBPACK_IMPORTED_MODULE_7__.stringify)(value)\n  }\n\n  // React only accepts `style` as object.\n  if (info.property === 'style') {\n    let styleObject =\n      typeof value === 'object' ? value : parseStyle(state, String(value))\n\n    if (state.stylePropertyNameCase === 'css') {\n      styleObject = transformStylesToCssCasing(styleObject)\n    }\n\n    return ['style', styleObject]\n  }\n\n  return [\n    state.elementAttributeNameCase === 'react' && info.space\n      ? property_information__WEBPACK_IMPORTED_MODULE_8__.hastToReact[info.property] || info.property\n      : info.attribute,\n    value\n  ]\n}\n\n/**\n * Parse a CSS declaration to an object.\n *\n * @param {State} state\n *   Info passed around.\n * @param {string} value\n *   CSS declarations.\n * @returns {Style}\n *   Properties.\n * @throws\n *   Throws `VFileMessage` when CSS cannot be parsed.\n */\nfunction parseStyle(state, value) {\n  /** @type {Style} */\n  const result = {}\n\n  try {\n    // @ts-expect-error: `style-to-object` types are broken.\n    ;(0,style_to_object__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(value, replacer)\n  } catch (error) {\n    if (!state.ignoreInvalidStyle) {\n      const cause = /** @type {Error} */ (error)\n      const message = new vfile_message__WEBPACK_IMPORTED_MODULE_9__.VFileMessage('Cannot parse `style` attribute', {\n        ancestors: state.ancestors,\n        cause,\n        ruleId: 'style',\n        source: 'hast-util-to-jsx-runtime'\n      })\n      message.file = state.filePath || undefined\n      message.url = docs + '#cannot-parse-style-attribute'\n\n      throw message\n    }\n  }\n\n  return result\n\n  /**\n   * Add a CSS property (normal, so with dashes) to `result` as a DOM CSS\n   * property.\n   *\n   * @param {string} name\n   *   Key.\n   * @param {string} value\n   *   Value\n   * @returns {undefined}\n   *   Nothing.\n   */\n  function replacer(name, value) {\n    let key = name\n\n    if (key.slice(0, 2) !== '--') {\n      if (key.slice(0, 4) === '-ms-') key = 'ms-' + key.slice(4)\n      key = key.replace(dashSomething, toCamel)\n    }\n\n    result[key] = value\n  }\n}\n\n/**\n * Create a JSX name from a string.\n *\n * @param {State} state\n *   To do.\n * @param {string} name\n *   Name.\n * @param {boolean} allowExpression\n *   Allow member expressions and identifiers.\n * @returns {unknown}\n *   To do.\n */\nfunction findComponentFromName(state, name, allowExpression) {\n  /** @type {Identifier | Literal | MemberExpression} */\n  let result\n\n  if (!allowExpression) {\n    result = {type: 'Literal', value: name}\n  } else if (name.includes('.')) {\n    const identifiers = name.split('.')\n    let index = -1\n    /** @type {Identifier | Literal | MemberExpression | undefined} */\n    let node\n\n    while (++index < identifiers.length) {\n      /** @type {Identifier | Literal} */\n      const prop = (0,estree_util_is_identifier_name__WEBPACK_IMPORTED_MODULE_10__.name)(identifiers[index])\n        ? {type: 'Identifier', name: identifiers[index]}\n        : {type: 'Literal', value: identifiers[index]}\n      node = node\n        ? {\n            type: 'MemberExpression',\n            object: node,\n            property: prop,\n            computed: Boolean(index && prop.type === 'Literal'),\n            optional: false\n          }\n        : prop\n    }\n\n    (0,devlop__WEBPACK_IMPORTED_MODULE_3__.ok)(node, 'always a result')\n    result = node\n  } else {\n    result =\n      (0,estree_util_is_identifier_name__WEBPACK_IMPORTED_MODULE_10__.name)(name) && !/^[a-z]/.test(name)\n        ? {type: 'Identifier', name}\n        : {type: 'Literal', value: name}\n  }\n\n  // Only literals can be passed in `components` currently.\n  // No identifiers / member expressions.\n  if (result.type === 'Literal') {\n    const name = /** @type {keyof JSX.IntrinsicElements} */ (result.value)\n\n    return own.call(state.components, name) ? state.components[name] : name\n  }\n\n  // Assume component.\n  if (state.evaluater) {\n    return state.evaluater.evaluateExpression(result)\n  }\n\n  crashEstree(state)\n}\n\n/**\n * @param {State} state\n * @param {Position | undefined} [place]\n * @returns {never}\n */\nfunction crashEstree(state, place) {\n  const message = new vfile_message__WEBPACK_IMPORTED_MODULE_9__.VFileMessage(\n    'Cannot handle MDX estrees without `createEvaluater`',\n    {\n      ancestors: state.ancestors,\n      place,\n      ruleId: 'mdx-estree',\n      source: 'hast-util-to-jsx-runtime'\n    }\n  )\n  message.file = state.filePath || undefined\n  message.url = docs + '#cannot-handle-mdx-estrees-without-createevaluater'\n\n  throw message\n}\n\n/**\n * Transform a DOM casing style object to a CSS casing style object.\n *\n * @param {Style} domCasing\n * @returns {Style}\n */\nfunction transformStylesToCssCasing(domCasing) {\n  /** @type {Style} */\n  const cssCasing = {}\n  /** @type {string} */\n  let from\n\n  for (from in domCasing) {\n    if (own.call(domCasing, from)) {\n      cssCasing[transformStyleToCssCasing(from)] = domCasing[from]\n    }\n  }\n\n  return cssCasing\n}\n\n/**\n * Transform a DOM casing style field to a CSS casing style field.\n *\n * @param {string} from\n * @returns {string}\n */\nfunction transformStyleToCssCasing(from) {\n  let to = from.replace(cap, toDash)\n  // Handle `ms-xxx` -> `-ms-xxx`.\n  if (to.slice(0, 3) === 'ms-') to = '-' + to\n  return to\n}\n\n/**\n * Make `$1` capitalized.\n *\n * @param {string} _\n *   Whatever.\n * @param {string} $1\n *   Single ASCII alphabetical.\n * @returns {string}\n *   Capitalized `$1`.\n */\nfunction toCamel(_, $1) {\n  return $1.toUpperCase()\n}\n\n/**\n * Make `$0` dash cased.\n *\n * @param {string} $0\n *   Capitalized ASCII leter.\n * @returns {string}\n *   Dash and lower letter.\n */\nfunction toDash($0) {\n  return '-' + $0.toLowerCase()\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2hhc3QtdXRpbC10by1qc3gtcnVudGltZS9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLDZCQUE2QjtBQUMxQyxhQUFhLDBCQUEwQjtBQUN2QyxhQUFhLG1DQUFtQztBQUNoRCxhQUFhLDZCQUE2QjtBQUMxQyxhQUFhLDBCQUEwQjtBQUN2QztBQUNBLGFBQWEsd0JBQXdCO0FBQ3JDLGFBQWEsc0JBQXNCO0FBQ25DLGFBQWEsd0JBQXdCO0FBQ3JDLGFBQWEscUJBQXFCO0FBQ2xDLGFBQWEscUJBQXFCO0FBQ2xDO0FBQ0EsYUFBYSwyREFBMkQ7QUFDeEUsYUFBYSwyREFBMkQ7QUFDeEU7QUFDQSxhQUFhLG9EQUFvRDtBQUNqRSxhQUFhLG9EQUFvRDtBQUNqRTtBQUNBLGFBQWEsNkNBQTZDO0FBQzFEO0FBQ0EsYUFBYSx1Q0FBdUM7QUFDcEQ7QUFDQSxhQUFhLDBCQUEwQjtBQUN2QztBQUNBLGFBQWEsc0NBQXNDO0FBQ25EOztBQUVBO0FBQ0EsYUFBYSx5Q0FBeUM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQSxXQUFXLG9CQUFvQjtBQUMvQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxvQkFBb0I7QUFDbEM7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQjtBQUNBO0FBQ0Es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QUFXLHNCQUFzQjtBQUNqQyxhQUFhO0FBQ2I7QUFDQTtBQUNBLHNCQUFzQix1REFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBLGFBQWEsUUFBUTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2dpdGh1Yl9teV9wb3J0Zm9saW8vLi4vbm9kZV9tb2R1bGVzL2hhc3QtdXRpbC10by1qc3gtcnVudGltZS9saWIvaW5kZXguanM/YjBkMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBSZWdpc3RlciBNRFggbm9kZXMgaW4gbWRhc3Q6XG4vLy8gPHJlZmVyZW5jZSB0eXBlcz1cIm1kYXN0LXV0aWwtbWR4LWV4cHJlc3Npb25cIiAvPlxuLy8vIDxyZWZlcmVuY2UgdHlwZXM9XCJtZGFzdC11dGlsLW1keC1qc3hcIiAvPlxuLy8vIDxyZWZlcmVuY2UgdHlwZXM9XCJtZGFzdC11dGlsLW1keGpzLWVzbVwiIC8+XG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnZXN0cmVlJykuSWRlbnRpZmllcn0gSWRlbnRpZmllclxuICogQHR5cGVkZWYge2ltcG9ydCgnZXN0cmVlJykuTGl0ZXJhbH0gTGl0ZXJhbFxuICogQHR5cGVkZWYge2ltcG9ydCgnZXN0cmVlJykuTWVtYmVyRXhwcmVzc2lvbn0gTWVtYmVyRXhwcmVzc2lvblxuICogQHR5cGVkZWYge2ltcG9ydCgnZXN0cmVlJykuRXhwcmVzc2lvbn0gRXhwcmVzc2lvblxuICogQHR5cGVkZWYge2ltcG9ydCgnZXN0cmVlJykuUHJvZ3JhbX0gUHJvZ3JhbVxuICpcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2hhc3QnKS5FbGVtZW50fSBFbGVtZW50XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdoYXN0JykuTm9kZXN9IE5vZGVzXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdoYXN0JykuUGFyZW50c30gUGFyZW50c1xuICogQHR5cGVkZWYge2ltcG9ydCgnaGFzdCcpLlJvb3R9IFJvb3RcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2hhc3QnKS5UZXh0fSBUZXh0XG4gKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QtdXRpbC1tZHgtZXhwcmVzc2lvbicpLk1keEZsb3dFeHByZXNzaW9uSGFzdH0gTWR4Rmxvd0V4cHJlc3Npb25cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0LXV0aWwtbWR4LWV4cHJlc3Npb24nKS5NZHhUZXh0RXhwcmVzc2lvbkhhc3R9IE1keFRleHRFeHByZXNzaW9uXG4gKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QtdXRpbC1tZHgtanN4JykuTWR4SnN4Rmxvd0VsZW1lbnRIYXN0fSBNZHhKc3hGbG93RWxlbWVudFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QtdXRpbC1tZHgtanN4JykuTWR4SnN4VGV4dEVsZW1lbnRIYXN0fSBNZHhKc3hUZXh0RWxlbWVudFxuICpcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0LXV0aWwtbWR4anMtZXNtJykuTWR4anNFc21IYXN0fSBNZHhqc0VzbVxuICpcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ3Byb3BlcnR5LWluZm9ybWF0aW9uJykuU2NoZW1hfSBTY2hlbWFcbiAqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCd1bmlzdCcpLlBvc2l0aW9ufSBQb3NpdGlvblxuICpcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vY29tcG9uZW50cy5qcycpLkNvbXBvbmVudHN9IENvbXBvbmVudHNcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtKU1guRWxlbWVudCB8IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWR9IENoaWxkXG4gKiAgIENoaWxkLlxuICpcbiAqIEBjYWxsYmFjayBDcmVhdGVcbiAqICAgQ3JlYXRlIHNvbWV0aGluZyBpbiBkZXZlbG9wbWVudCBvciBwcm9kdWN0aW9uLlxuICogQHBhcmFtIHtOb2Rlc30gbm9kZVxuICogICBoYXN0IG5vZGUuXG4gKiBAcGFyYW0ge3Vua25vd259IHR5cGVcbiAqICAgRnJhZ21lbnQgc3ltYm9sIG9yIHRhZyBuYW1lLlxuICogQHBhcmFtIHtQcm9wc30gcHJvcHNcbiAqICAgUHJvcGVydGllcyBhbmQgY2hpbGRyZW4uXG4gKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0ga2V5XG4gKiAgIEtleS5cbiAqIEByZXR1cm5zIHtKU1guRWxlbWVudH1cbiAqICAgUmVzdWx0LlxuICpcbiAqIEBjYWxsYmFjayBDcmVhdGVFdmFsdWF0ZXJcbiAqICAgQ3JlYXRlIGFuIGV2YWx1YXRvciB0aGF0IHR1cm5zIEVTVHJlZSBBU1RzIGZyb20gZW1iZWRkZWQgTURYIGludG8gdmFsdWVzLlxuICogQHJldHVybnMge0V2YWx1YXRlcn1cbiAqICAgRXZhbHVhdGVyLlxuICpcbiAqIEB0eXBlZGVmIHsnaHRtbCcgfCAncmVhY3QnfSBFbGVtZW50QXR0cmlidXRlTmFtZUNhc2VcbiAqICAgQ2FzaW5nIHRvIHVzZSBmb3IgYXR0cmlidXRlIG5hbWVzLlxuICpcbiAqICAgSFRNTCBjYXNpbmcgaXMgZm9yIGV4YW1wbGUgYGNsYXNzYCwgYHN0cm9rZS1saW5lY2FwYCwgYHhtbDpsYW5nYC5cbiAqICAgUmVhY3QgY2FzaW5nIGlzIGZvciBleGFtcGxlIGBjbGFzc05hbWVgLCBgc3Ryb2tlTGluZWNhcGAsIGB4bWxMYW5nYC5cbiAqXG4gKiBAY2FsbGJhY2sgRXZhbHVhdGVFeHByZXNzaW9uXG4gKiAgIFR1cm4gYW4gTURYIGV4cHJlc3Npb24gaW50byBhIHZhbHVlLlxuICogQHBhcmFtIHtFeHByZXNzaW9ufSBleHByZXNzaW9uXG4gKiAgIEVTVHJlZSBleHByZXNzaW9uLlxuICogQHJldHVybnMge3Vua25vd259XG4gKiAgIFJlc3VsdCBvZiBleHByZXNzaW9uLlxuICpcbiAqIEBjYWxsYmFjayBFdmFsdWF0ZVByb2dyYW1cbiAqICAgVHVybiBhbiBNRFggcHJvZ3JhbSAoZXhwb3J0L2ltcG9ydCBzdGF0ZW1lbnRzKSBpbnRvIGEgdmFsdWUuXG4gKiBAcGFyYW0ge1Byb2dyYW19IGV4cHJlc3Npb25cbiAqICAgRVNUcmVlIHByb2dyYW0uXG4gKiBAcmV0dXJucyB7dW5rbm93bn1cbiAqICAgUmVzdWx0IG9mIHByb2dyYW07XG4gKiAgIHNob3VsZCBsaWtlbHkgYmUgYHVuZGVmaW5lZGAgYXMgRVNNIGNoYW5nZXMgdGhlIHNjb3BlIGJ1dCBkb2VzbuKAmXQgeWllbGRcbiAqICAgc29tZXRoaW5nLlxuICpcbiAqIEB0eXBlZGVmIEV2YWx1YXRlclxuICogICBFdmFsdWF0b3IgdGhhdCB0dXJucyBFU1RyZWUgQVNUcyBmcm9tIGVtYmVkZGVkIE1EWCBpbnRvIHZhbHVlcy5cbiAqIEBwcm9wZXJ0eSB7RXZhbHVhdGVFeHByZXNzaW9ufSBldmFsdWF0ZUV4cHJlc3Npb25cbiAqICAgRXZhbHVhdGUgYW4gZXhwcmVzc2lvbi5cbiAqIEBwcm9wZXJ0eSB7RXZhbHVhdGVQcm9ncmFtfSBldmFsdWF0ZVByb2dyYW1cbiAqICAgRXZhbHVhdGUgYSBwcm9ncmFtLlxuICpcbiAqIEB0eXBlZGVmIHtbc3RyaW5nLCBWYWx1ZV19IEZpZWxkXG4gKiAgIFByb3BlcnR5IGZpZWxkLlxuICpcbiAqIEB0eXBlZGVmIHt1bmtub3dufSBGcmFnbWVudFxuICogICBSZXByZXNlbnQgdGhlIGNoaWxkcmVuLCB0eXBpY2FsbHkgYSBzeW1ib2wuXG4gKlxuICogQGNhbGxiYWNrIEpzeFxuICogICBDcmVhdGUgYSBwcm9kdWN0aW9uIGVsZW1lbnQuXG4gKiBAcGFyYW0ge3Vua25vd259IHR5cGVcbiAqICAgRWxlbWVudCB0eXBlOiBgRnJhZ21lbnRgIHN5bWJvbCwgdGFnIG5hbWUgKGBzdHJpbmdgKSwgY29tcG9uZW50LlxuICogQHBhcmFtIHtQcm9wc30gcHJvcHNcbiAqICAgRWxlbWVudCBwcm9wcywgYGNoaWxkcmVuYCwgYW5kIG1heWJlIGBub2RlYC5cbiAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBba2V5XVxuICogICBEeW5hbWljbHkgZ2VuZXJhdGVkIGtleSB0byB1c2UuXG4gKiBAcmV0dXJucyB7SlNYLkVsZW1lbnR9XG4gKiAgIEVsZW1lbnQgZnJvbSB5b3VyIGZyYW1ld29yay5cbiAqXG4gKiBAY2FsbGJhY2sgSnN4RGV2XG4gKiAgIENyZWF0ZSBhIGRldmVsb3BtZW50IGVsZW1lbnQuXG4gKiBAcGFyYW0ge3Vua25vd259IHR5cGVcbiAqICAgRWxlbWVudCB0eXBlOiBgRnJhZ21lbnRgIHN5bWJvbCwgdGFnIG5hbWUgKGBzdHJpbmdgKSwgY29tcG9uZW50LlxuICogQHBhcmFtIHtQcm9wc30gcHJvcHNcbiAqICAgRWxlbWVudCBwcm9wcywgYGNoaWxkcmVuYCwgYW5kIG1heWJlIGBub2RlYC5cbiAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBrZXlcbiAqICAgRHluYW1pY2x5IGdlbmVyYXRlZCBrZXkgdG8gdXNlLlxuICogQHBhcmFtIHtib29sZWFufSBpc1N0YXRpY0NoaWxkcmVuXG4gKiAgIFdoZXRoZXIgdHdvIG9yIG1vcmUgY2hpbGRyZW4gYXJlIHBhc3NlZCAoaW4gYW4gYXJyYXkpLCB3aGljaCBpcyB3aGV0aGVyXG4gKiAgIGBqc3hzYCBvciBganN4YCB3b3VsZCBiZSB1c2VkLlxuICogQHBhcmFtIHtTb3VyY2V9IHNvdXJjZVxuICogICBJbmZvIGFib3V0IHNvdXJjZS5cbiAqIEBwYXJhbSB7dW5kZWZpbmVkfSBzZWxmXG4gKiAgIE5vdGhpbmcgKHRoaXMgaXMgdXNlZCBieSBmcmFtZXdvcmtzIHRoYXQgaGF2ZSBjb21wb25lbnRzLCB3ZSBkb27igJl0KS5cbiAqIEByZXR1cm5zIHtKU1guRWxlbWVudH1cbiAqICAgRWxlbWVudCBmcm9tIHlvdXIgZnJhbWV3b3JrLlxuICpcbiAqIEB0eXBlZGVmIHt7Y2hpbGRyZW4/OiBBcnJheTxDaGlsZD4gfCBDaGlsZCwgbm9kZT86IEVsZW1lbnQgfCBNZHhKc3hGbG93RWxlbWVudCB8IE1keEpzeFRleHRFbGVtZW50IHwgdW5kZWZpbmVkLCBbcHJvcDogc3RyaW5nXTogQXJyYXk8Q2hpbGQ+IHwgQ2hpbGQgfCBFbGVtZW50IHwgTWR4SnN4Rmxvd0VsZW1lbnQgfCBNZHhKc3hUZXh0RWxlbWVudCB8IFZhbHVlIHwgdW5kZWZpbmVkfX0gUHJvcHNcbiAqICAgUHJvcGVydGllcyBhbmQgY2hpbGRyZW4uXG4gKlxuICogQHR5cGVkZWYgUmVndWxhckZpZWxkc1xuICogICBDb25maWd1cmF0aW9uLlxuICogQHByb3BlcnR5IHtQYXJ0aWFsPENvbXBvbmVudHM+IHwgbnVsbCB8IHVuZGVmaW5lZH0gW2NvbXBvbmVudHNdXG4gKiAgIENvbXBvbmVudHMgdG8gdXNlIChvcHRpb25hbCkuXG4gKiBAcHJvcGVydHkge0NyZWF0ZUV2YWx1YXRlciB8IG51bGwgfCB1bmRlZmluZWR9IFtjcmVhdGVFdmFsdWF0ZXJdXG4gKiAgIENyZWF0ZSBhbiBldmFsdWF0b3IgdGhhdCB0dXJucyBFU1RyZWUgQVNUcyBpbnRvIHZhbHVlcyAob3B0aW9uYWwpLlxuICogQHByb3BlcnR5IHtFbGVtZW50QXR0cmlidXRlTmFtZUNhc2UgfCBudWxsIHwgdW5kZWZpbmVkfSBbZWxlbWVudEF0dHJpYnV0ZU5hbWVDYXNlPSdyZWFjdCddXG4gKiAgIFNwZWNpZnkgY2FzaW5nIHRvIHVzZSBmb3IgYXR0cmlidXRlIG5hbWVzIChkZWZhdWx0OiBgJ3JlYWN0J2ApLlxuICogQHByb3BlcnR5IHtzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkfSBbZmlsZVBhdGhdXG4gKiAgIEZpbGUgcGF0aCB0byB0aGUgb3JpZ2luYWwgc291cmNlIGZpbGUgKG9wdGlvbmFsKS5cbiAqXG4gKiAgIFBhc3NlZCBpbiBzb3VyY2UgaW5mbyB0byBganN4REVWYCB3aGVuIHVzaW5nIHRoZSBhdXRvbWF0aWMgcnVudGltZSB3aXRoXG4gKiAgIGBkZXZlbG9wbWVudDogdHJ1ZWAuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW4gfCBudWxsIHwgdW5kZWZpbmVkfSBbaWdub3JlSW52YWxpZFN0eWxlPWZhbHNlXVxuICogICBJZ25vcmUgaW52YWxpZCBDU1MgaW4gYHN0eWxlYCBwcm9wcyAoZGVmYXVsdDogYGZhbHNlYCk7XG4gKiAgIHRoZSBkZWZhdWx0IGJlaGF2aW9yIGlzIHRvIHRocm93IGFuIGVycm9yLlxuICogQHByb3BlcnR5IHtib29sZWFuIHwgbnVsbCB8IHVuZGVmaW5lZH0gW3Bhc3NLZXlzPXRydWVdXG4gKiAgIEdlbmVyYXRlIGtleXMgdG8gb3B0aW1pemUgZnJhbWV3b3JrcyB0aGF0IHN1cHBvcnQgdGhlbSAoZGVmYXVsdDogYHRydWVgKS5cbiAqXG4gKiAgID4g8J+RiSAqKk5vdGUqKjogU29saWQgY3VycmVudGx5IGZhaWxzIGlmIGtleXMgYXJlIHBhc3NlZC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbiB8IG51bGwgfCB1bmRlZmluZWR9IFtwYXNzTm9kZT1mYWxzZV1cbiAqICAgUGFzcyB0aGUgaGFzdCBlbGVtZW50IG5vZGUgdG8gY29tcG9uZW50cyAoZGVmYXVsdDogYGZhbHNlYCkuXG4gKiBAcHJvcGVydHkge1NwYWNlIHwgbnVsbCB8IHVuZGVmaW5lZH0gW3NwYWNlPSdodG1sJ11cbiAqICAgV2hldGhlciBgdHJlZWAgaXMgaW4gdGhlIGAnaHRtbCdgIG9yIGAnc3ZnJ2Agc3BhY2UgKGRlZmF1bHQ6IGAnaHRtbCdgKS5cbiAqXG4gKiAgIFdoZW4gYW4gYDxzdmc+YCBlbGVtZW50IGlzIGZvdW5kIGluIHRoZSBIVE1MIHNwYWNlLCB0aGlzIHBhY2thZ2UgYWxyZWFkeVxuICogICBhdXRvbWF0aWNhbGx5IHN3aXRjaGVzIHRvIGFuZCBmcm9tIHRoZSBTVkcgc3BhY2Ugd2hlbiBlbnRlcmluZyBhbmQgZXhpdGluZ1xuICogICBpdC5cbiAqIEBwcm9wZXJ0eSB7U3R5bGVQcm9wZXJ0eU5hbWVDYXNlIHwgbnVsbCB8IHVuZGVmaW5lZH0gW3N0eWxlUHJvcGVydHlOYW1lQ2FzZT0nZG9tJ11cbiAqICAgU3BlY2lmeSBjYXNpbmcgdG8gdXNlIGZvciBwcm9wZXJ0eSBuYW1lcyBpbiBgc3R5bGVgIG9iamVjdHMgKGRlZmF1bHQ6XG4gKiAgIGAnZG9tJ2ApLlxuICogQHByb3BlcnR5IHtib29sZWFuIHwgbnVsbCB8IHVuZGVmaW5lZH0gW3RhYmxlQ2VsbEFsaWduVG9TdHlsZT10cnVlXVxuICogICBUdXJuIG9ic29sZXRlIGBhbGlnbmAgcHJvcHMgb24gYHRkYCBhbmQgYHRoYCBpbnRvIENTUyBgc3R5bGVgIHByb3BzXG4gKiAgIChkZWZhdWx0OiBgdHJ1ZWApLlxuICpcbiAqIEB0eXBlZGVmIFJ1bnRpbWVEZXZlbG9wbWVudFxuICogICBSdW50aW1lIGZpZWxkcyB3aGVuIGRldmVsb3BtZW50IGlzIG9uLlxuICogQHByb3BlcnR5IHtGcmFnbWVudH0gRnJhZ21lbnRcbiAqICAgRnJhZ21lbnQuXG4gKiBAcHJvcGVydHkge3RydWV9IGRldmVsb3BtZW50XG4gKiAgIFdoZXRoZXIgdG8gdXNlIGBqc3hERVZgICh3aGVuIG9uKSBvciBganN4YCBhbmQgYGpzeHNgICh3aGVuIG9mZikuXG4gKiBAcHJvcGVydHkge0pzeCB8IG51bGwgfCB1bmRlZmluZWR9IFtqc3hdXG4gKiAgIER5bmFtaWMgSlNYIChvcHRpb25hbCkuXG4gKiBAcHJvcGVydHkge0pzeERldn0ganN4REVWXG4gKiAgIERldmVsb3BtZW50IEpTWC5cbiAqIEBwcm9wZXJ0eSB7SnN4IHwgbnVsbCB8IHVuZGVmaW5lZH0gW2pzeHNdXG4gKiAgIFN0YXRpYyBKU1ggKG9wdGlvbmFsKS5cbiAqXG4gKiBAdHlwZWRlZiBSdW50aW1lUHJvZHVjdGlvblxuICogICBSdW50aW1lIGZpZWxkcyB3aGVuIGRldmVsb3BtZW50IGlzIG9mZi5cbiAqIEBwcm9wZXJ0eSB7RnJhZ21lbnR9IEZyYWdtZW50XG4gKiAgIEZyYWdtZW50LlxuICogQHByb3BlcnR5IHtmYWxzZSB8IG51bGwgfCB1bmRlZmluZWR9IFtkZXZlbG9wbWVudF1cbiAqICAgV2hldGhlciB0byB1c2UgYGpzeERFVmAgKHdoZW4gb24pIG9yIGBqc3hgIGFuZCBganN4c2AgKHdoZW4gb2ZmKSAob3B0aW9uYWwpLlxuICogQHByb3BlcnR5IHtKc3h9IGpzeFxuICogICBEeW5hbWljIEpTWC5cbiAqIEBwcm9wZXJ0eSB7SnN4RGV2IHwgbnVsbCB8IHVuZGVmaW5lZH0gW2pzeERFVl1cbiAqICAgRGV2ZWxvcG1lbnQgSlNYIChvcHRpb25hbCkuXG4gKiBAcHJvcGVydHkge0pzeH0ganN4c1xuICogICBTdGF0aWMgSlNYLlxuICpcbiAqIEB0eXBlZGVmIFJ1bnRpbWVVbmtub3duXG4gKiAgIFJ1bnRpbWUgZmllbGRzIHdoZW4gZGV2ZWxvcG1lbnQgbWlnaHQgYmUgb24gb3Igb2ZmLlxuICogQHByb3BlcnR5IHtGcmFnbWVudH0gRnJhZ21lbnRcbiAqICAgRnJhZ21lbnQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGRldmVsb3BtZW50XG4gKiAgIFdoZXRoZXIgdG8gdXNlIGBqc3hERVZgICh3aGVuIG9uKSBvciBganN4YCBhbmQgYGpzeHNgICh3aGVuIG9mZikuXG4gKiBAcHJvcGVydHkge0pzeCB8IG51bGwgfCB1bmRlZmluZWR9IFtqc3hdXG4gKiAgIER5bmFtaWMgSlNYIChvcHRpb25hbCkuXG4gKiBAcHJvcGVydHkge0pzeERldiB8IG51bGwgfCB1bmRlZmluZWR9IFtqc3hERVZdXG4gKiAgIERldmVsb3BtZW50IEpTWCAob3B0aW9uYWwpLlxuICogQHByb3BlcnR5IHtKc3ggfCBudWxsIHwgdW5kZWZpbmVkfSBbanN4c11cbiAqICAgU3RhdGljIEpTWCAob3B0aW9uYWwpLlxuICpcbiAqIEB0eXBlZGVmIFNvdXJjZVxuICogICBJbmZvIGFib3V0IHNvdXJjZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyIHwgdW5kZWZpbmVkfSBjb2x1bW5OdW1iZXJcbiAqICAgQ29sdW1uIHdoZXJlIHRoaW5nIHN0YXJ0cyAoMC1pbmRleGVkKS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBmaWxlTmFtZVxuICogICBOYW1lIG9mIHNvdXJjZSBmaWxlLlxuICogQHByb3BlcnR5IHtudW1iZXIgfCB1bmRlZmluZWR9IGxpbmVOdW1iZXJcbiAqICAgTGluZSB3aGVyZSB0aGluZyBzdGFydHMgKDEtaW5kZXhlZCkuXG4gKlxuICogQHR5cGVkZWYgeydodG1sJyB8ICdzdmcnfSBTcGFjZVxuICogICBOYW1lc3BhY2UuXG4gKlxuICogICA+IPCfkYkgKipOb3RlKio6IGhhc3QgaXMgbm90IFhNTC5cbiAqICAgPiBJdCBzdXBwb3J0cyBTVkcgYXMgZW1iZWRkZWQgaW4gSFRNTC5cbiAqICAgPiBJdCBkb2VzIG5vdCBzdXBwb3J0IHRoZSBmZWF0dXJlcyBhdmFpbGFibGUgaW4gWE1MLlxuICogICA+IFBhc3NpbmcgU1ZHIG1pZ2h0IGJyZWFrIGJ1dCBmcmFnbWVudHMgb2YgbW9kZXJuIFNWRyBzaG91bGQgYmUgZmluZS5cbiAqICAgPiBVc2UgYHhhc3RgIGlmIHlvdSBuZWVkIHRvIHN1cHBvcnQgU1ZHIGFzIFhNTC5cbiAqXG4gKiBAdHlwZWRlZiBTdGF0ZVxuICogICBJbmZvIHBhc3NlZCBhcm91bmQuXG4gKiBAcHJvcGVydHkge3Vua25vd259IEZyYWdtZW50XG4gKiAgIEZyYWdtZW50IHN5bWJvbC5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8UGFyZW50cz59IGFuY2VzdG9yc1xuICogICBTdGFjayBvZiBwYXJlbnRzLlxuICogQHByb3BlcnR5IHtQYXJ0aWFsPENvbXBvbmVudHM+fSBjb21wb25lbnRzXG4gKiAgIENvbXBvbmVudHMgdG8gc3dhcC5cbiAqIEBwcm9wZXJ0eSB7Q3JlYXRlfSBjcmVhdGVcbiAqICAgQ3JlYXRlIHNvbWV0aGluZyBpbiBkZXZlbG9wbWVudCBvciBwcm9kdWN0aW9uLlxuICogQHByb3BlcnR5IHtFbGVtZW50QXR0cmlidXRlTmFtZUNhc2V9IGVsZW1lbnRBdHRyaWJ1dGVOYW1lQ2FzZVxuICogICBDYXNpbmcgdG8gdXNlIGZvciBhdHRyaWJ1dGUgbmFtZXMuXG4gKiBAcHJvcGVydHkge0V2YWx1YXRlciB8IHVuZGVmaW5lZH0gZXZhbHVhdGVyXG4gKiAgIEV2YWx1YXRvciB0aGF0IHR1cm5zIEVTVHJlZSBBU1RzIGludG8gdmFsdWVzLlxuICogQHByb3BlcnR5IHtzdHJpbmcgfCB1bmRlZmluZWR9IGZpbGVQYXRoXG4gKiAgIEZpbGUgcGF0aC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaWdub3JlSW52YWxpZFN0eWxlXG4gKiAgIElnbm9yZSBpbnZhbGlkIENTUyBpbiBgc3R5bGVgIHByb3BzLlxuICogQHByb3BlcnR5IHtib29sZWFufSBwYXNzS2V5c1xuICogICBHZW5lcmF0ZSBrZXlzIHRvIG9wdGltaXplIGZyYW1ld29ya3MgdGhhdCBzdXBwb3J0IHRoZW0uXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHBhc3NOb2RlXG4gKiAgIFBhc3MgYG5vZGVgIHRvIGNvbXBvbmVudHMuXG4gKiBAcHJvcGVydHkge1NjaGVtYX0gc2NoZW1hXG4gKiAgIEN1cnJlbnQgc2NoZW1hLlxuICogQHByb3BlcnR5IHtTdHlsZVByb3BlcnR5TmFtZUNhc2V9IHN0eWxlUHJvcGVydHlOYW1lQ2FzZVxuICogICBDYXNpbmcgdG8gdXNlIGZvciBwcm9wZXJ0eSBuYW1lcyBpbiBgc3R5bGVgIG9iamVjdHMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHRhYmxlQ2VsbEFsaWduVG9TdHlsZVxuICogICBUdXJuIG9ic29sZXRlIGBhbGlnbmAgcHJvcHMgb24gYHRkYCBhbmQgYHRoYCBpbnRvIENTUyBgc3R5bGVgIHByb3BzLlxuICpcbiAqIEB0eXBlZGVmIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+fSBTdHlsZVxuICogICBTdHlsZSBtYXAuXG4gKlxuICogQHR5cGVkZWYgeydjc3MnIHwgJ2RvbSd9IFN0eWxlUHJvcGVydHlOYW1lQ2FzZVxuICogICBDYXNpbmcgdG8gdXNlIGZvciBwcm9wZXJ0eSBuYW1lcyBpbiBgc3R5bGVgIG9iamVjdHMuXG4gKlxuICogICBDU1MgY2FzaW5nIGlzIGZvciBleGFtcGxlIGBiYWNrZ3JvdW5kLWNvbG9yYCBhbmQgYC13ZWJraXQtbGluZS1jbGFtcGAuXG4gKiAgIERPTSBjYXNpbmcgaXMgZm9yIGV4YW1wbGUgYGJhY2tncm91bmRDb2xvcmAgYW5kIGBXZWJraXRMaW5lQ2xhbXBgLlxuICpcbiAqIEB0eXBlZGVmIHtTdHlsZSB8IGJvb2xlYW4gfCBudW1iZXIgfCBzdHJpbmd9IFZhbHVlXG4gKiAgIFByaW1pdGl2ZSBwcm9wZXJ0eSB2YWx1ZSBhbmQgYFN0eWxlYCBtYXAuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7UnVudGltZURldmVsb3BtZW50ICYgUmVndWxhckZpZWxkc30gRGV2ZWxvcG1lbnRcbiAqICAgQ29uZmlndXJhdGlvbiAoZGV2ZWxvcG1lbnQpLlxuICogQHR5cGVkZWYge0RldmVsb3BtZW50IHwgUHJvZHVjdGlvbiB8IFVua25vd259IE9wdGlvbnNcbiAqICAgQ29uZmlndXJhdGlvbi5cbiAqIEB0eXBlZGVmIHtSZWd1bGFyRmllbGRzICYgUnVudGltZVByb2R1Y3Rpb259IFByb2R1Y3Rpb25cbiAqICAgQ29uZmlndXJhdGlvbiAocHJvZHVjdGlvbikuXG4gKiBAdHlwZWRlZiB7UmVndWxhckZpZWxkcyAmIFJ1bnRpbWVVbmtub3dufSBVbmtub3duXG4gKiAgIENvbmZpZ3VyYXRpb24gKHByb2R1Y3Rpb24gb3IgZGV2ZWxvcG1lbnQpLlxuICovXG5cbmltcG9ydCB7c3RyaW5naWZ5IGFzIGNvbW1hc30gZnJvbSAnY29tbWEtc2VwYXJhdGVkLXRva2VucydcbmltcG9ydCB7b2sgYXMgYXNzZXJ0fSBmcm9tICdkZXZsb3AnXG5pbXBvcnQge25hbWUgYXMgaXNJZGVudGlmaWVyTmFtZX0gZnJvbSAnZXN0cmVlLXV0aWwtaXMtaWRlbnRpZmllci1uYW1lJ1xuaW1wb3J0IHt3aGl0ZXNwYWNlfSBmcm9tICdoYXN0LXV0aWwtd2hpdGVzcGFjZSdcbmltcG9ydCB7ZmluZCwgaGFzdFRvUmVhY3QsIGh0bWwsIHN2Z30gZnJvbSAncHJvcGVydHktaW5mb3JtYXRpb24nXG5pbXBvcnQge3N0cmluZ2lmeSBhcyBzcGFjZXN9IGZyb20gJ3NwYWNlLXNlcGFyYXRlZC10b2tlbnMnXG5pbXBvcnQgc3R5bGVUb09iamVjdCBmcm9tICdzdHlsZS10by1vYmplY3QnXG5pbXBvcnQge3BvaW50U3RhcnR9IGZyb20gJ3VuaXN0LXV0aWwtcG9zaXRpb24nXG5pbXBvcnQge1ZGaWxlTWVzc2FnZX0gZnJvbSAndmZpbGUtbWVzc2FnZSdcblxuY29uc3Qgb3duID0ge30uaGFzT3duUHJvcGVydHlcblxuLyoqIEB0eXBlIHtNYXA8c3RyaW5nLCBudW1iZXI+fSAqL1xuY29uc3QgZW1wdHlNYXAgPSBuZXcgTWFwKClcblxuY29uc3QgY2FwID0gL1tBLVpdL2dcbmNvbnN0IGRhc2hTb21ldGhpbmcgPSAvLShbYS16XSkvZ1xuXG4vLyBgcmVhY3QtZG9tYCB0cmlnZ2VycyBhIHdhcm5pbmcgZm9yICphbnkqIHdoaXRlIHNwYWNlIGluIHRhYmxlcy5cbi8vIFRvIGZvbGxvdyBHRk0sIGBtZGFzdC11dGlsLXRvLWhhc3RgIGluamVjdHMgbGluZSBlbmRpbmdzIGJldHdlZW4gZWxlbWVudHMuXG4vLyBPdGhlciB0b29scyBtaWdodCBkbyBzbyB0b28sIGJ1dCB0aGV5IGRvbuKAmXQgZG8gaGVyZSwgc28gd2UgcmVtb3ZlIGFsbCBvZlxuLy8gdGhhdC5cblxuLy8gU2VlOiA8aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvNzA4MT4uXG4vLyBTZWU6IDxodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC83NTE1Pi5cbi8vIFNlZTogPGh0dHBzOi8vZ2l0aHViLmNvbS9yZW1hcmtqcy9yZW1hcmstcmVhY3QvaXNzdWVzLzY0Pi5cbi8vIFNlZTogPGh0dHBzOi8vZ2l0aHViLmNvbS9yZWh5cGVqcy9yZWh5cGUtcmVhY3QvcHVsbC8yOT4uXG4vLyBTZWU6IDxodHRwczovL2dpdGh1Yi5jb20vcmVoeXBlanMvcmVoeXBlLXJlYWN0L3B1bGwvMzI+LlxuLy8gU2VlOiA8aHR0cHM6Ly9naXRodWIuY29tL3JlaHlwZWpzL3JlaHlwZS1yZWFjdC9wdWxsLzQ1Pi5cbmNvbnN0IHRhYmxlRWxlbWVudHMgPSBuZXcgU2V0KFsndGFibGUnLCAndGJvZHknLCAndGhlYWQnLCAndGZvb3QnLCAndHInXSlcblxuY29uc3QgdGFibGVDZWxsRWxlbWVudCA9IG5ldyBTZXQoWyd0ZCcsICd0aCddKVxuXG5jb25zdCBkb2NzID0gJ2h0dHBzOi8vZ2l0aHViLmNvbS9zeW50YXgtdHJlZS9oYXN0LXV0aWwtdG8tanN4LXJ1bnRpbWUnXG5cbi8qKlxuICogVHJhbnNmb3JtIGEgaGFzdCB0cmVlIHRvIHByZWFjdCwgcmVhY3QsIHNvbGlkLCBzdmVsdGUsIHZ1ZSwgZXRjLixcbiAqIHdpdGggYW4gYXV0b21hdGljIEpTWCBydW50aW1lLlxuICpcbiAqIEBwYXJhbSB7Tm9kZXN9IHRyZWVcbiAqICAgVHJlZSB0byB0cmFuc2Zvcm0uXG4gKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnNcbiAqICAgQ29uZmlndXJhdGlvbiAocmVxdWlyZWQpLlxuICogQHJldHVybnMge0pTWC5FbGVtZW50fVxuICogICBKU1ggZWxlbWVudC5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdG9Kc3hSdW50aW1lKHRyZWUsIG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zIHx8IG9wdGlvbnMuRnJhZ21lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGBGcmFnbWVudGAgaW4gb3B0aW9ucycpXG4gIH1cblxuICBjb25zdCBmaWxlUGF0aCA9IG9wdGlvbnMuZmlsZVBhdGggfHwgdW5kZWZpbmVkXG4gIC8qKiBAdHlwZSB7Q3JlYXRlfSAqL1xuICBsZXQgY3JlYXRlXG5cbiAgaWYgKG9wdGlvbnMuZGV2ZWxvcG1lbnQpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuanN4REVWICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnRXhwZWN0ZWQgYGpzeERFVmAgaW4gb3B0aW9ucyB3aGVuIGBkZXZlbG9wbWVudDogdHJ1ZWAnXG4gICAgICApXG4gICAgfVxuXG4gICAgY3JlYXRlID0gZGV2ZWxvcG1lbnRDcmVhdGUoZmlsZVBhdGgsIG9wdGlvbnMuanN4REVWKVxuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5qc3ggIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGBqc3hgIGluIHByb2R1Y3Rpb24gb3B0aW9ucycpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmpzeHMgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGBqc3hzYCBpbiBwcm9kdWN0aW9uIG9wdGlvbnMnKVxuICAgIH1cblxuICAgIGNyZWF0ZSA9IHByb2R1Y3Rpb25DcmVhdGUoZmlsZVBhdGgsIG9wdGlvbnMuanN4LCBvcHRpb25zLmpzeHMpXG4gIH1cblxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuICBjb25zdCBzdGF0ZSA9IHtcbiAgICBGcmFnbWVudDogb3B0aW9ucy5GcmFnbWVudCxcbiAgICBhbmNlc3RvcnM6IFtdLFxuICAgIGNvbXBvbmVudHM6IG9wdGlvbnMuY29tcG9uZW50cyB8fCB7fSxcbiAgICBjcmVhdGUsXG4gICAgZWxlbWVudEF0dHJpYnV0ZU5hbWVDYXNlOiBvcHRpb25zLmVsZW1lbnRBdHRyaWJ1dGVOYW1lQ2FzZSB8fCAncmVhY3QnLFxuICAgIGV2YWx1YXRlcjogb3B0aW9ucy5jcmVhdGVFdmFsdWF0ZXIgPyBvcHRpb25zLmNyZWF0ZUV2YWx1YXRlcigpIDogdW5kZWZpbmVkLFxuICAgIGZpbGVQYXRoLFxuICAgIGlnbm9yZUludmFsaWRTdHlsZTogb3B0aW9ucy5pZ25vcmVJbnZhbGlkU3R5bGUgfHwgZmFsc2UsXG4gICAgcGFzc0tleXM6IG9wdGlvbnMucGFzc0tleXMgIT09IGZhbHNlLFxuICAgIHBhc3NOb2RlOiBvcHRpb25zLnBhc3NOb2RlIHx8IGZhbHNlLFxuICAgIHNjaGVtYTogb3B0aW9ucy5zcGFjZSA9PT0gJ3N2ZycgPyBzdmcgOiBodG1sLFxuICAgIHN0eWxlUHJvcGVydHlOYW1lQ2FzZTogb3B0aW9ucy5zdHlsZVByb3BlcnR5TmFtZUNhc2UgfHwgJ2RvbScsXG4gICAgdGFibGVDZWxsQWxpZ25Ub1N0eWxlOiBvcHRpb25zLnRhYmxlQ2VsbEFsaWduVG9TdHlsZSAhPT0gZmFsc2VcbiAgfVxuXG4gIGNvbnN0IHJlc3VsdCA9IG9uZShzdGF0ZSwgdHJlZSwgdW5kZWZpbmVkKVxuXG4gIC8vIEpTWCBlbGVtZW50LlxuICBpZiAocmVzdWx0ICYmIHR5cGVvZiByZXN1bHQgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgLy8gVGV4dCBub2RlIG9yIHNvbWV0aGluZyB0aGF0IHR1cm5lZCBpbnRvIG5vdGhpbmcuXG4gIHJldHVybiBzdGF0ZS5jcmVhdGUoXG4gICAgdHJlZSxcbiAgICBzdGF0ZS5GcmFnbWVudCxcbiAgICB7Y2hpbGRyZW46IHJlc3VsdCB8fCB1bmRlZmluZWR9LFxuICAgIHVuZGVmaW5lZFxuICApXG59XG5cbi8qKlxuICogVHJhbnNmb3JtIGEgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZVxuICogICBJbmZvIHBhc3NlZCBhcm91bmQuXG4gKiBAcGFyYW0ge05vZGVzfSBub2RlXG4gKiAgIEN1cnJlbnQgbm9kZS5cbiAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBrZXlcbiAqICAgS2V5LlxuICogQHJldHVybnMge0NoaWxkIHwgdW5kZWZpbmVkfVxuICogICBDaGlsZCwgb3B0aW9uYWwuXG4gKi9cbmZ1bmN0aW9uIG9uZShzdGF0ZSwgbm9kZSwga2V5KSB7XG4gIGlmIChub2RlLnR5cGUgPT09ICdlbGVtZW50Jykge1xuICAgIHJldHVybiBlbGVtZW50KHN0YXRlLCBub2RlLCBrZXkpXG4gIH1cblxuICBpZiAobm9kZS50eXBlID09PSAnbWR4Rmxvd0V4cHJlc3Npb24nIHx8IG5vZGUudHlwZSA9PT0gJ21keFRleHRFeHByZXNzaW9uJykge1xuICAgIHJldHVybiBtZHhFeHByZXNzaW9uKHN0YXRlLCBub2RlKVxuICB9XG5cbiAgaWYgKG5vZGUudHlwZSA9PT0gJ21keEpzeEZsb3dFbGVtZW50JyB8fCBub2RlLnR5cGUgPT09ICdtZHhKc3hUZXh0RWxlbWVudCcpIHtcbiAgICByZXR1cm4gbWR4SnN4RWxlbWVudChzdGF0ZSwgbm9kZSwga2V5KVxuICB9XG5cbiAgaWYgKG5vZGUudHlwZSA9PT0gJ21keGpzRXNtJykge1xuICAgIHJldHVybiBtZHhFc20oc3RhdGUsIG5vZGUpXG4gIH1cblxuICBpZiAobm9kZS50eXBlID09PSAncm9vdCcpIHtcbiAgICByZXR1cm4gcm9vdChzdGF0ZSwgbm9kZSwga2V5KVxuICB9XG5cbiAgaWYgKG5vZGUudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgcmV0dXJuIHRleHQoc3RhdGUsIG5vZGUpXG4gIH1cbn1cblxuLyoqXG4gKiBIYW5kbGUgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZVxuICogICBJbmZvIHBhc3NlZCBhcm91bmQuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGVcbiAqICAgQ3VycmVudCBub2RlLlxuICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IGtleVxuICogICBLZXkuXG4gKiBAcmV0dXJucyB7Q2hpbGQgfCB1bmRlZmluZWR9XG4gKiAgIENoaWxkLCBvcHRpb25hbC5cbiAqL1xuZnVuY3Rpb24gZWxlbWVudChzdGF0ZSwgbm9kZSwga2V5KSB7XG4gIGNvbnN0IHBhcmVudFNjaGVtYSA9IHN0YXRlLnNjaGVtYVxuICBsZXQgc2NoZW1hID0gcGFyZW50U2NoZW1hXG5cbiAgaWYgKG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnc3ZnJyAmJiBwYXJlbnRTY2hlbWEuc3BhY2UgPT09ICdodG1sJykge1xuICAgIHNjaGVtYSA9IHN2Z1xuICAgIHN0YXRlLnNjaGVtYSA9IHNjaGVtYVxuICB9XG5cbiAgc3RhdGUuYW5jZXN0b3JzLnB1c2gobm9kZSlcblxuICBjb25zdCB0eXBlID0gZmluZENvbXBvbmVudEZyb21OYW1lKHN0YXRlLCBub2RlLnRhZ05hbWUsIGZhbHNlKVxuICBjb25zdCBwcm9wcyA9IGNyZWF0ZUVsZW1lbnRQcm9wcyhzdGF0ZSwgbm9kZSlcbiAgbGV0IGNoaWxkcmVuID0gY3JlYXRlQ2hpbGRyZW4oc3RhdGUsIG5vZGUpXG5cbiAgaWYgKHRhYmxlRWxlbWVudHMuaGFzKG5vZGUudGFnTmFtZSkpIHtcbiAgICBjaGlsZHJlbiA9IGNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgY2hpbGQgPT09ICdzdHJpbmcnID8gIXdoaXRlc3BhY2UoY2hpbGQpIDogdHJ1ZVxuICAgIH0pXG4gIH1cblxuICBhZGROb2RlKHN0YXRlLCBwcm9wcywgdHlwZSwgbm9kZSlcbiAgYWRkQ2hpbGRyZW4ocHJvcHMsIGNoaWxkcmVuKVxuXG4gIC8vIFJlc3RvcmUuXG4gIHN0YXRlLmFuY2VzdG9ycy5wb3AoKVxuICBzdGF0ZS5zY2hlbWEgPSBwYXJlbnRTY2hlbWFcblxuICByZXR1cm4gc3RhdGUuY3JlYXRlKG5vZGUsIHR5cGUsIHByb3BzLCBrZXkpXG59XG5cbi8qKlxuICogSGFuZGxlIE1EWCBleHByZXNzaW9uLlxuICpcbiAqIEBwYXJhbSB7U3RhdGV9IHN0YXRlXG4gKiAgIEluZm8gcGFzc2VkIGFyb3VuZC5cbiAqIEBwYXJhbSB7TWR4Rmxvd0V4cHJlc3Npb24gfCBNZHhUZXh0RXhwcmVzc2lvbn0gbm9kZVxuICogICBDdXJyZW50IG5vZGUuXG4gKiBAcmV0dXJucyB7Q2hpbGQgfCB1bmRlZmluZWR9XG4gKiAgIENoaWxkLCBvcHRpb25hbC5cbiAqL1xuZnVuY3Rpb24gbWR4RXhwcmVzc2lvbihzdGF0ZSwgbm9kZSkge1xuICBpZiAobm9kZS5kYXRhICYmIG5vZGUuZGF0YS5lc3RyZWUgJiYgc3RhdGUuZXZhbHVhdGVyKSB7XG4gICAgY29uc3QgcHJvZ3JhbSA9IG5vZGUuZGF0YS5lc3RyZWVcbiAgICBjb25zdCBleHByZXNzaW9uID0gcHJvZ3JhbS5ib2R5WzBdXG4gICAgYXNzZXJ0KGV4cHJlc3Npb24udHlwZSA9PT0gJ0V4cHJlc3Npb25TdGF0ZW1lbnQnKVxuXG4gICAgLy8gQXNzdW1lIHJlc3VsdCBpcyBhIGNoaWxkLlxuICAgIHJldHVybiAvKiogQHR5cGUge0NoaWxkIHwgdW5kZWZpbmVkfSAqLyAoXG4gICAgICBzdGF0ZS5ldmFsdWF0ZXIuZXZhbHVhdGVFeHByZXNzaW9uKGV4cHJlc3Npb24uZXhwcmVzc2lvbilcbiAgICApXG4gIH1cblxuICBjcmFzaEVzdHJlZShzdGF0ZSwgbm9kZS5wb3NpdGlvbilcbn1cblxuLyoqXG4gKiBIYW5kbGUgTURYIEVTTS5cbiAqXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZVxuICogICBJbmZvIHBhc3NlZCBhcm91bmQuXG4gKiBAcGFyYW0ge01keGpzRXNtfSBub2RlXG4gKiAgIEN1cnJlbnQgbm9kZS5cbiAqIEByZXR1cm5zIHtDaGlsZCB8IHVuZGVmaW5lZH1cbiAqICAgQ2hpbGQsIG9wdGlvbmFsLlxuICovXG5mdW5jdGlvbiBtZHhFc20oc3RhdGUsIG5vZGUpIHtcbiAgaWYgKG5vZGUuZGF0YSAmJiBub2RlLmRhdGEuZXN0cmVlICYmIHN0YXRlLmV2YWx1YXRlcikge1xuICAgIC8vIEFzc3VtZSByZXN1bHQgaXMgYSBjaGlsZC5cbiAgICByZXR1cm4gLyoqIEB0eXBlIHtDaGlsZCB8IHVuZGVmaW5lZH0gKi8gKFxuICAgICAgc3RhdGUuZXZhbHVhdGVyLmV2YWx1YXRlUHJvZ3JhbShub2RlLmRhdGEuZXN0cmVlKVxuICAgIClcbiAgfVxuXG4gIGNyYXNoRXN0cmVlKHN0YXRlLCBub2RlLnBvc2l0aW9uKVxufVxuXG4vKipcbiAqIEhhbmRsZSBNRFggSlNYLlxuICpcbiAqIEBwYXJhbSB7U3RhdGV9IHN0YXRlXG4gKiAgIEluZm8gcGFzc2VkIGFyb3VuZC5cbiAqIEBwYXJhbSB7TWR4SnN4Rmxvd0VsZW1lbnQgfCBNZHhKc3hUZXh0RWxlbWVudH0gbm9kZVxuICogICBDdXJyZW50IG5vZGUuXG4gKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0ga2V5XG4gKiAgIEtleS5cbiAqIEByZXR1cm5zIHtDaGlsZCB8IHVuZGVmaW5lZH1cbiAqICAgQ2hpbGQsIG9wdGlvbmFsLlxuICovXG5mdW5jdGlvbiBtZHhKc3hFbGVtZW50KHN0YXRlLCBub2RlLCBrZXkpIHtcbiAgY29uc3QgcGFyZW50U2NoZW1hID0gc3RhdGUuc2NoZW1hXG4gIGxldCBzY2hlbWEgPSBwYXJlbnRTY2hlbWFcblxuICBpZiAobm9kZS5uYW1lID09PSAnc3ZnJyAmJiBwYXJlbnRTY2hlbWEuc3BhY2UgPT09ICdodG1sJykge1xuICAgIHNjaGVtYSA9IHN2Z1xuICAgIHN0YXRlLnNjaGVtYSA9IHNjaGVtYVxuICB9XG5cbiAgc3RhdGUuYW5jZXN0b3JzLnB1c2gobm9kZSlcblxuICBjb25zdCB0eXBlID1cbiAgICBub2RlLm5hbWUgPT09IG51bGxcbiAgICAgID8gc3RhdGUuRnJhZ21lbnRcbiAgICAgIDogZmluZENvbXBvbmVudEZyb21OYW1lKHN0YXRlLCBub2RlLm5hbWUsIHRydWUpXG4gIGNvbnN0IHByb3BzID0gY3JlYXRlSnN4RWxlbWVudFByb3BzKHN0YXRlLCBub2RlKVxuICBjb25zdCBjaGlsZHJlbiA9IGNyZWF0ZUNoaWxkcmVuKHN0YXRlLCBub2RlKVxuXG4gIGFkZE5vZGUoc3RhdGUsIHByb3BzLCB0eXBlLCBub2RlKVxuICBhZGRDaGlsZHJlbihwcm9wcywgY2hpbGRyZW4pXG5cbiAgLy8gUmVzdG9yZS5cbiAgc3RhdGUuYW5jZXN0b3JzLnBvcCgpXG4gIHN0YXRlLnNjaGVtYSA9IHBhcmVudFNjaGVtYVxuXG4gIHJldHVybiBzdGF0ZS5jcmVhdGUobm9kZSwgdHlwZSwgcHJvcHMsIGtleSlcbn1cblxuLyoqXG4gKiBIYW5kbGUgcm9vdC5cbiAqXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZVxuICogICBJbmZvIHBhc3NlZCBhcm91bmQuXG4gKiBAcGFyYW0ge1Jvb3R9IG5vZGVcbiAqICAgQ3VycmVudCBub2RlLlxuICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IGtleVxuICogICBLZXkuXG4gKiBAcmV0dXJucyB7Q2hpbGQgfCB1bmRlZmluZWR9XG4gKiAgIENoaWxkLCBvcHRpb25hbC5cbiAqL1xuZnVuY3Rpb24gcm9vdChzdGF0ZSwgbm9kZSwga2V5KSB7XG4gIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gIGNvbnN0IHByb3BzID0ge31cblxuICBhZGRDaGlsZHJlbihwcm9wcywgY3JlYXRlQ2hpbGRyZW4oc3RhdGUsIG5vZGUpKVxuXG4gIHJldHVybiBzdGF0ZS5jcmVhdGUobm9kZSwgc3RhdGUuRnJhZ21lbnQsIHByb3BzLCBrZXkpXG59XG5cbi8qKlxuICogSGFuZGxlIHRleHQuXG4gKlxuICogQHBhcmFtIHtTdGF0ZX0gX1xuICogICBJbmZvIHBhc3NlZCBhcm91bmQuXG4gKiBAcGFyYW0ge1RleHR9IG5vZGVcbiAqICAgQ3VycmVudCBub2RlLlxuICogQHJldHVybnMge0NoaWxkIHwgdW5kZWZpbmVkfVxuICogICBDaGlsZCwgb3B0aW9uYWwuXG4gKi9cbmZ1bmN0aW9uIHRleHQoXywgbm9kZSkge1xuICByZXR1cm4gbm9kZS52YWx1ZVxufVxuXG4vKipcbiAqIEFkZCBgbm9kZWAgdG8gcHJvcHMuXG4gKlxuICogQHBhcmFtIHtTdGF0ZX0gc3RhdGVcbiAqICAgSW5mbyBwYXNzZWQgYXJvdW5kLlxuICogQHBhcmFtIHtQcm9wc30gcHJvcHNcbiAqICAgUHJvcHMuXG4gKiBAcGFyYW0ge3Vua25vd259IHR5cGVcbiAqICAgVHlwZS5cbiAqIEBwYXJhbSB7RWxlbWVudCB8IE1keEpzeEZsb3dFbGVtZW50IHwgTWR4SnN4VGV4dEVsZW1lbnR9IG5vZGVcbiAqICAgTm9kZS5cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiAgIE5vdGhpbmcuXG4gKi9cbmZ1bmN0aW9uIGFkZE5vZGUoc3RhdGUsIHByb3BzLCB0eXBlLCBub2RlKSB7XG4gIC8vIElmIHRoaXMgaXMgc3dhcHBlZCBvdXQgZm9yIGEgY29tcG9uZW50OlxuICBpZiAodHlwZW9mIHR5cGUgIT09ICdzdHJpbmcnICYmIHR5cGUgIT09IHN0YXRlLkZyYWdtZW50ICYmIHN0YXRlLnBhc3NOb2RlKSB7XG4gICAgcHJvcHMubm9kZSA9IG5vZGVcbiAgfVxufVxuXG4vKipcbiAqIEFkZCBjaGlsZHJlbiB0byBwcm9wcy5cbiAqXG4gKiBAcGFyYW0ge1Byb3BzfSBwcm9wc1xuICogICBQcm9wcy5cbiAqIEBwYXJhbSB7QXJyYXk8Q2hpbGQ+fSBjaGlsZHJlblxuICogICBDaGlsZHJlbi5cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiAgIE5vdGhpbmcuXG4gKi9cbmZ1bmN0aW9uIGFkZENoaWxkcmVuKHByb3BzLCBjaGlsZHJlbikge1xuICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IHZhbHVlID0gY2hpbGRyZW4ubGVuZ3RoID4gMSA/IGNoaWxkcmVuIDogY2hpbGRyZW5bMF1cblxuICAgIGlmICh2YWx1ZSkge1xuICAgICAgcHJvcHMuY2hpbGRyZW4gPSB2YWx1ZVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBfXG4gKiAgIFBhdGggdG8gZmlsZS5cbiAqIEBwYXJhbSB7SnN4fSBqc3hcbiAqICAgRHluYW1pYy5cbiAqIEBwYXJhbSB7SnN4fSBqc3hzXG4gKiAgIFN0YXRpYy5cbiAqIEByZXR1cm5zIHtDcmVhdGV9XG4gKiAgIENyZWF0ZSBhIHByb2R1Y3Rpb24gZWxlbWVudC5cbiAqL1xuZnVuY3Rpb24gcHJvZHVjdGlvbkNyZWF0ZShfLCBqc3gsIGpzeHMpIHtcbiAgcmV0dXJuIGNyZWF0ZVxuICAvKiogQHR5cGUge0NyZWF0ZX0gKi9cbiAgZnVuY3Rpb24gY3JlYXRlKF8sIHR5cGUsIHByb3BzLCBrZXkpIHtcbiAgICAvLyBPbmx5IGFuIGFycmF5IHdoZW4gdGhlcmUgYXJlIDIgb3IgbW9yZSBjaGlsZHJlbi5cbiAgICBjb25zdCBpc1N0YXRpY0NoaWxkcmVuID0gQXJyYXkuaXNBcnJheShwcm9wcy5jaGlsZHJlbilcbiAgICBjb25zdCBmbiA9IGlzU3RhdGljQ2hpbGRyZW4gPyBqc3hzIDoganN4XG4gICAgcmV0dXJuIGtleSA/IGZuKHR5cGUsIHByb3BzLCBrZXkpIDogZm4odHlwZSwgcHJvcHMpXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gZmlsZVBhdGhcbiAqICAgUGF0aCB0byBmaWxlLlxuICogQHBhcmFtIHtKc3hEZXZ9IGpzeERFVlxuICogICBEZXZlbG9wbWVudC5cbiAqIEByZXR1cm5zIHtDcmVhdGV9XG4gKiAgIENyZWF0ZSBhIGRldmVsb3BtZW50IGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIGRldmVsb3BtZW50Q3JlYXRlKGZpbGVQYXRoLCBqc3hERVYpIHtcbiAgcmV0dXJuIGNyZWF0ZVxuICAvKiogQHR5cGUge0NyZWF0ZX0gKi9cbiAgZnVuY3Rpb24gY3JlYXRlKG5vZGUsIHR5cGUsIHByb3BzLCBrZXkpIHtcbiAgICAvLyBPbmx5IGFuIGFycmF5IHdoZW4gdGhlcmUgYXJlIDIgb3IgbW9yZSBjaGlsZHJlbi5cbiAgICBjb25zdCBpc1N0YXRpY0NoaWxkcmVuID0gQXJyYXkuaXNBcnJheShwcm9wcy5jaGlsZHJlbilcbiAgICBjb25zdCBwb2ludCA9IHBvaW50U3RhcnQobm9kZSlcbiAgICByZXR1cm4ganN4REVWKFxuICAgICAgdHlwZSxcbiAgICAgIHByb3BzLFxuICAgICAga2V5LFxuICAgICAgaXNTdGF0aWNDaGlsZHJlbixcbiAgICAgIHtcbiAgICAgICAgY29sdW1uTnVtYmVyOiBwb2ludCA/IHBvaW50LmNvbHVtbiAtIDEgOiB1bmRlZmluZWQsXG4gICAgICAgIGZpbGVOYW1lOiBmaWxlUGF0aCxcbiAgICAgICAgbGluZU51bWJlcjogcG9pbnQgPyBwb2ludC5saW5lIDogdW5kZWZpbmVkXG4gICAgICB9LFxuICAgICAgdW5kZWZpbmVkXG4gICAgKVxuICB9XG59XG5cbi8qKlxuICogQ3JlYXRlIHByb3BzIGZyb20gYW4gZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZVxuICogICBJbmZvIHBhc3NlZCBhcm91bmQuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGVcbiAqICAgQ3VycmVudCBlbGVtZW50LlxuICogQHJldHVybnMge1Byb3BzfVxuICogICBQcm9wcy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRWxlbWVudFByb3BzKHN0YXRlLCBub2RlKSB7XG4gIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gIGNvbnN0IHByb3BzID0ge31cbiAgLyoqIEB0eXBlIHtzdHJpbmcgfCB1bmRlZmluZWR9ICovXG4gIGxldCBhbGlnblZhbHVlXG4gIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICBsZXQgcHJvcFxuXG4gIGZvciAocHJvcCBpbiBub2RlLnByb3BlcnRpZXMpIHtcbiAgICBpZiAocHJvcCAhPT0gJ2NoaWxkcmVuJyAmJiBvd24uY2FsbChub2RlLnByb3BlcnRpZXMsIHByb3ApKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBjcmVhdGVQcm9wZXJ0eShzdGF0ZSwgcHJvcCwgbm9kZS5wcm9wZXJ0aWVzW3Byb3BdKVxuXG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIGNvbnN0IFtrZXksIHZhbHVlXSA9IHJlc3VsdFxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICBzdGF0ZS50YWJsZUNlbGxBbGlnblRvU3R5bGUgJiZcbiAgICAgICAgICBrZXkgPT09ICdhbGlnbicgJiZcbiAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgdGFibGVDZWxsRWxlbWVudC5oYXMobm9kZS50YWdOYW1lKVxuICAgICAgICApIHtcbiAgICAgICAgICBhbGlnblZhbHVlID0gdmFsdWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9wc1trZXldID0gdmFsdWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChhbGlnblZhbHVlKSB7XG4gICAgLy8gQXNzdW1lIHN0eWxlIGlzIGFuIG9iamVjdC5cbiAgICBjb25zdCBzdHlsZSA9IC8qKiBAdHlwZSB7U3R5bGV9ICovIChwcm9wcy5zdHlsZSB8fCAocHJvcHMuc3R5bGUgPSB7fSkpXG4gICAgc3R5bGVbc3RhdGUuc3R5bGVQcm9wZXJ0eU5hbWVDYXNlID09PSAnY3NzJyA/ICd0ZXh0LWFsaWduJyA6ICd0ZXh0QWxpZ24nXSA9XG4gICAgICBhbGlnblZhbHVlXG4gIH1cblxuICByZXR1cm4gcHJvcHNcbn1cblxuLyoqXG4gKiBDcmVhdGUgcHJvcHMgZnJvbSBhIEpTWCBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7U3RhdGV9IHN0YXRlXG4gKiAgIEluZm8gcGFzc2VkIGFyb3VuZC5cbiAqIEBwYXJhbSB7TWR4SnN4Rmxvd0VsZW1lbnQgfCBNZHhKc3hUZXh0RWxlbWVudH0gbm9kZVxuICogICBDdXJyZW50IEpTWCBlbGVtZW50LlxuICogQHJldHVybnMge1Byb3BzfVxuICogICBQcm9wcy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSnN4RWxlbWVudFByb3BzKHN0YXRlLCBub2RlKSB7XG4gIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gIGNvbnN0IHByb3BzID0ge31cblxuICBmb3IgKGNvbnN0IGF0dHJpYnV0ZSBvZiBub2RlLmF0dHJpYnV0ZXMpIHtcbiAgICBpZiAoYXR0cmlidXRlLnR5cGUgPT09ICdtZHhKc3hFeHByZXNzaW9uQXR0cmlidXRlJykge1xuICAgICAgaWYgKGF0dHJpYnV0ZS5kYXRhICYmIGF0dHJpYnV0ZS5kYXRhLmVzdHJlZSAmJiBzdGF0ZS5ldmFsdWF0ZXIpIHtcbiAgICAgICAgY29uc3QgcHJvZ3JhbSA9IGF0dHJpYnV0ZS5kYXRhLmVzdHJlZVxuICAgICAgICBjb25zdCBleHByZXNzaW9uID0gcHJvZ3JhbS5ib2R5WzBdXG4gICAgICAgIGFzc2VydChleHByZXNzaW9uLnR5cGUgPT09ICdFeHByZXNzaW9uU3RhdGVtZW50JylcbiAgICAgICAgY29uc3Qgb2JqZWN0RXhwcmVzc2lvbiA9IGV4cHJlc3Npb24uZXhwcmVzc2lvblxuICAgICAgICBhc3NlcnQob2JqZWN0RXhwcmVzc2lvbi50eXBlID09PSAnT2JqZWN0RXhwcmVzc2lvbicpXG4gICAgICAgIGNvbnN0IHByb3BlcnR5ID0gb2JqZWN0RXhwcmVzc2lvbi5wcm9wZXJ0aWVzWzBdXG4gICAgICAgIGFzc2VydChwcm9wZXJ0eS50eXBlID09PSAnU3ByZWFkRWxlbWVudCcpXG5cbiAgICAgICAgT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICBzdGF0ZS5ldmFsdWF0ZXIuZXZhbHVhdGVFeHByZXNzaW9uKHByb3BlcnR5LmFyZ3VtZW50KVxuICAgICAgICApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjcmFzaEVzdHJlZShzdGF0ZSwgbm9kZS5wb3NpdGlvbilcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRm9yIEpTWCwgdGhlIGF1dGhvciBpcyByZXNwb25zaWJsZSBvZiBwYXNzaW5nIGluIHRoZSBjb3JyZWN0IHZhbHVlcy5cbiAgICAgIGNvbnN0IG5hbWUgPSBhdHRyaWJ1dGUubmFtZVxuICAgICAgLyoqIEB0eXBlIHt1bmtub3dufSAqL1xuICAgICAgbGV0IHZhbHVlXG5cbiAgICAgIGlmIChhdHRyaWJ1dGUudmFsdWUgJiYgdHlwZW9mIGF0dHJpYnV0ZS52YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGF0dHJpYnV0ZS52YWx1ZS5kYXRhICYmXG4gICAgICAgICAgYXR0cmlidXRlLnZhbHVlLmRhdGEuZXN0cmVlICYmXG4gICAgICAgICAgc3RhdGUuZXZhbHVhdGVyXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnN0IHByb2dyYW0gPSBhdHRyaWJ1dGUudmFsdWUuZGF0YS5lc3RyZWVcbiAgICAgICAgICBjb25zdCBleHByZXNzaW9uID0gcHJvZ3JhbS5ib2R5WzBdXG4gICAgICAgICAgYXNzZXJ0KGV4cHJlc3Npb24udHlwZSA9PT0gJ0V4cHJlc3Npb25TdGF0ZW1lbnQnKVxuICAgICAgICAgIHZhbHVlID0gc3RhdGUuZXZhbHVhdGVyLmV2YWx1YXRlRXhwcmVzc2lvbihleHByZXNzaW9uLmV4cHJlc3Npb24pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3Jhc2hFc3RyZWUoc3RhdGUsIG5vZGUucG9zaXRpb24pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gYXR0cmlidXRlLnZhbHVlID09PSBudWxsID8gdHJ1ZSA6IGF0dHJpYnV0ZS52YWx1ZVxuICAgICAgfVxuXG4gICAgICAvLyBBc3N1bWUgYSBwcm9wLlxuICAgICAgcHJvcHNbbmFtZV0gPSAvKiogQHR5cGUge1Byb3BzW2tleW9mIFByb3BzXX0gKi8gKHZhbHVlKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwcm9wc1xufVxuXG4vKipcbiAqIENyZWF0ZSBjaGlsZHJlbi5cbiAqXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZVxuICogICBJbmZvIHBhc3NlZCBhcm91bmQuXG4gKiBAcGFyYW0ge1BhcmVudHN9IG5vZGVcbiAqICAgQ3VycmVudCBlbGVtZW50LlxuICogQHJldHVybnMge0FycmF5PENoaWxkPn1cbiAqICAgQ2hpbGRyZW4uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNoaWxkcmVuKHN0YXRlLCBub2RlKSB7XG4gIC8qKiBAdHlwZSB7QXJyYXk8Q2hpbGQ+fSAqL1xuICBjb25zdCBjaGlsZHJlbiA9IFtdXG4gIGxldCBpbmRleCA9IC0xXG4gIC8qKiBAdHlwZSB7TWFwPHN0cmluZywgbnVtYmVyPn0gKi9cbiAgLy8gTm90ZTogdGVzdCB0aGlzIHdoZW4gU29saWQgZG9lc27igJl0IHdhbnQgdG8gbWVyZ2UgbXkgdXBjb21pbmcgUFIuXG4gIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gIGNvbnN0IGNvdW50c0J5TmFtZSA9IHN0YXRlLnBhc3NLZXlzID8gbmV3IE1hcCgpIDogZW1wdHlNYXBcblxuICB3aGlsZSAoKytpbmRleCA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgY29uc3QgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2luZGV4XVxuICAgIC8qKiBAdHlwZSB7c3RyaW5nIHwgdW5kZWZpbmVkfSAqL1xuICAgIGxldCBrZXlcblxuICAgIGlmIChzdGF0ZS5wYXNzS2V5cykge1xuICAgICAgY29uc3QgbmFtZSA9XG4gICAgICAgIGNoaWxkLnR5cGUgPT09ICdlbGVtZW50J1xuICAgICAgICAgID8gY2hpbGQudGFnTmFtZVxuICAgICAgICAgIDogY2hpbGQudHlwZSA9PT0gJ21keEpzeEZsb3dFbGVtZW50JyB8fFxuICAgICAgICAgICAgICBjaGlsZC50eXBlID09PSAnbWR4SnN4VGV4dEVsZW1lbnQnXG4gICAgICAgICAgICA/IGNoaWxkLm5hbWVcbiAgICAgICAgICAgIDogdW5kZWZpbmVkXG5cbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIGNvbnN0IGNvdW50ID0gY291bnRzQnlOYW1lLmdldChuYW1lKSB8fCAwXG4gICAgICAgIGtleSA9IG5hbWUgKyAnLScgKyBjb3VudFxuICAgICAgICBjb3VudHNCeU5hbWUuc2V0KG5hbWUsIGNvdW50ICsgMSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSBvbmUoc3RhdGUsIGNoaWxkLCBrZXkpXG4gICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSBjaGlsZHJlbi5wdXNoKHJlc3VsdClcbiAgfVxuXG4gIHJldHVybiBjaGlsZHJlblxufVxuXG4vKipcbiAqIEhhbmRsZSBhIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7U3RhdGV9IHN0YXRlXG4gKiAgIEluZm8gcGFzc2VkIGFyb3VuZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wXG4gKiAgIEtleS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyIHwgc3RyaW5nPiB8IGJvb2xlYW4gfCBudW1iZXIgfCBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkfSB2YWx1ZVxuICogICBoYXN0IHByb3BlcnR5IHZhbHVlLlxuICogQHJldHVybnMge0ZpZWxkIHwgdW5kZWZpbmVkfVxuICogICBGaWVsZCBmb3IgcnVudGltZSwgb3B0aW9uYWwuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVByb3BlcnR5KHN0YXRlLCBwcm9wLCB2YWx1ZSkge1xuICBjb25zdCBpbmZvID0gZmluZChzdGF0ZS5zY2hlbWEsIHByb3ApXG5cbiAgLy8gSWdub3JlIG51bGxpc2ggYW5kIGBOYU5gIHZhbHVlcy5cbiAgaWYgKFxuICAgIHZhbHVlID09PSBudWxsIHx8XG4gICAgdmFsdWUgPT09IHVuZGVmaW5lZCB8fFxuICAgICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIE51bWJlci5pc05hTih2YWx1ZSkpXG4gICkge1xuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgLy8gQWNjZXB0IGBhcnJheWAuXG4gICAgLy8gTW9zdCBwcm9wcyBhcmUgc3BhY2Utc2VwYXJhdGVkLlxuICAgIHZhbHVlID0gaW5mby5jb21tYVNlcGFyYXRlZCA/IGNvbW1hcyh2YWx1ZSkgOiBzcGFjZXModmFsdWUpXG4gIH1cblxuICAvLyBSZWFjdCBvbmx5IGFjY2VwdHMgYHN0eWxlYCBhcyBvYmplY3QuXG4gIGlmIChpbmZvLnByb3BlcnR5ID09PSAnc3R5bGUnKSB7XG4gICAgbGV0IHN0eWxlT2JqZWN0ID1cbiAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgPyB2YWx1ZSA6IHBhcnNlU3R5bGUoc3RhdGUsIFN0cmluZyh2YWx1ZSkpXG5cbiAgICBpZiAoc3RhdGUuc3R5bGVQcm9wZXJ0eU5hbWVDYXNlID09PSAnY3NzJykge1xuICAgICAgc3R5bGVPYmplY3QgPSB0cmFuc2Zvcm1TdHlsZXNUb0Nzc0Nhc2luZyhzdHlsZU9iamVjdClcbiAgICB9XG5cbiAgICByZXR1cm4gWydzdHlsZScsIHN0eWxlT2JqZWN0XVxuICB9XG5cbiAgcmV0dXJuIFtcbiAgICBzdGF0ZS5lbGVtZW50QXR0cmlidXRlTmFtZUNhc2UgPT09ICdyZWFjdCcgJiYgaW5mby5zcGFjZVxuICAgICAgPyBoYXN0VG9SZWFjdFtpbmZvLnByb3BlcnR5XSB8fCBpbmZvLnByb3BlcnR5XG4gICAgICA6IGluZm8uYXR0cmlidXRlLFxuICAgIHZhbHVlXG4gIF1cbn1cblxuLyoqXG4gKiBQYXJzZSBhIENTUyBkZWNsYXJhdGlvbiB0byBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtTdGF0ZX0gc3RhdGVcbiAqICAgSW5mbyBwYXNzZWQgYXJvdW5kLlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiAgIENTUyBkZWNsYXJhdGlvbnMuXG4gKiBAcmV0dXJucyB7U3R5bGV9XG4gKiAgIFByb3BlcnRpZXMuXG4gKiBAdGhyb3dzXG4gKiAgIFRocm93cyBgVkZpbGVNZXNzYWdlYCB3aGVuIENTUyBjYW5ub3QgYmUgcGFyc2VkLlxuICovXG5mdW5jdGlvbiBwYXJzZVN0eWxlKHN0YXRlLCB2YWx1ZSkge1xuICAvKiogQHR5cGUge1N0eWxlfSAqL1xuICBjb25zdCByZXN1bHQgPSB7fVxuXG4gIHRyeSB7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogYHN0eWxlLXRvLW9iamVjdGAgdHlwZXMgYXJlIGJyb2tlbi5cbiAgICBzdHlsZVRvT2JqZWN0KHZhbHVlLCByZXBsYWNlcilcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoIXN0YXRlLmlnbm9yZUludmFsaWRTdHlsZSkge1xuICAgICAgY29uc3QgY2F1c2UgPSAvKiogQHR5cGUge0Vycm9yfSAqLyAoZXJyb3IpXG4gICAgICBjb25zdCBtZXNzYWdlID0gbmV3IFZGaWxlTWVzc2FnZSgnQ2Fubm90IHBhcnNlIGBzdHlsZWAgYXR0cmlidXRlJywge1xuICAgICAgICBhbmNlc3RvcnM6IHN0YXRlLmFuY2VzdG9ycyxcbiAgICAgICAgY2F1c2UsXG4gICAgICAgIHJ1bGVJZDogJ3N0eWxlJyxcbiAgICAgICAgc291cmNlOiAnaGFzdC11dGlsLXRvLWpzeC1ydW50aW1lJ1xuICAgICAgfSlcbiAgICAgIG1lc3NhZ2UuZmlsZSA9IHN0YXRlLmZpbGVQYXRoIHx8IHVuZGVmaW5lZFxuICAgICAgbWVzc2FnZS51cmwgPSBkb2NzICsgJyNjYW5ub3QtcGFyc2Utc3R5bGUtYXR0cmlidXRlJ1xuXG4gICAgICB0aHJvdyBtZXNzYWdlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxuXG4gIC8qKlxuICAgKiBBZGQgYSBDU1MgcHJvcGVydHkgKG5vcm1hbCwgc28gd2l0aCBkYXNoZXMpIHRvIGByZXN1bHRgIGFzIGEgRE9NIENTU1xuICAgKiBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogICBLZXkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKiAgIFZhbHVlXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAqICAgTm90aGluZy5cbiAgICovXG4gIGZ1bmN0aW9uIHJlcGxhY2VyKG5hbWUsIHZhbHVlKSB7XG4gICAgbGV0IGtleSA9IG5hbWVcblxuICAgIGlmIChrZXkuc2xpY2UoMCwgMikgIT09ICctLScpIHtcbiAgICAgIGlmIChrZXkuc2xpY2UoMCwgNCkgPT09ICctbXMtJykga2V5ID0gJ21zLScgKyBrZXkuc2xpY2UoNClcbiAgICAgIGtleSA9IGtleS5yZXBsYWNlKGRhc2hTb21ldGhpbmcsIHRvQ2FtZWwpXG4gICAgfVxuXG4gICAgcmVzdWx0W2tleV0gPSB2YWx1ZVxuICB9XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgSlNYIG5hbWUgZnJvbSBhIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZVxuICogICBUbyBkby5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiAgIE5hbWUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGFsbG93RXhwcmVzc2lvblxuICogICBBbGxvdyBtZW1iZXIgZXhwcmVzc2lvbnMgYW5kIGlkZW50aWZpZXJzLlxuICogQHJldHVybnMge3Vua25vd259XG4gKiAgIFRvIGRvLlxuICovXG5mdW5jdGlvbiBmaW5kQ29tcG9uZW50RnJvbU5hbWUoc3RhdGUsIG5hbWUsIGFsbG93RXhwcmVzc2lvbikge1xuICAvKiogQHR5cGUge0lkZW50aWZpZXIgfCBMaXRlcmFsIHwgTWVtYmVyRXhwcmVzc2lvbn0gKi9cbiAgbGV0IHJlc3VsdFxuXG4gIGlmICghYWxsb3dFeHByZXNzaW9uKSB7XG4gICAgcmVzdWx0ID0ge3R5cGU6ICdMaXRlcmFsJywgdmFsdWU6IG5hbWV9XG4gIH0gZWxzZSBpZiAobmFtZS5pbmNsdWRlcygnLicpKSB7XG4gICAgY29uc3QgaWRlbnRpZmllcnMgPSBuYW1lLnNwbGl0KCcuJylcbiAgICBsZXQgaW5kZXggPSAtMVxuICAgIC8qKiBAdHlwZSB7SWRlbnRpZmllciB8IExpdGVyYWwgfCBNZW1iZXJFeHByZXNzaW9uIHwgdW5kZWZpbmVkfSAqL1xuICAgIGxldCBub2RlXG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGlkZW50aWZpZXJzLmxlbmd0aCkge1xuICAgICAgLyoqIEB0eXBlIHtJZGVudGlmaWVyIHwgTGl0ZXJhbH0gKi9cbiAgICAgIGNvbnN0IHByb3AgPSBpc0lkZW50aWZpZXJOYW1lKGlkZW50aWZpZXJzW2luZGV4XSlcbiAgICAgICAgPyB7dHlwZTogJ0lkZW50aWZpZXInLCBuYW1lOiBpZGVudGlmaWVyc1tpbmRleF19XG4gICAgICAgIDoge3R5cGU6ICdMaXRlcmFsJywgdmFsdWU6IGlkZW50aWZpZXJzW2luZGV4XX1cbiAgICAgIG5vZGUgPSBub2RlXG4gICAgICAgID8ge1xuICAgICAgICAgICAgdHlwZTogJ01lbWJlckV4cHJlc3Npb24nLFxuICAgICAgICAgICAgb2JqZWN0OiBub2RlLFxuICAgICAgICAgICAgcHJvcGVydHk6IHByb3AsXG4gICAgICAgICAgICBjb21wdXRlZDogQm9vbGVhbihpbmRleCAmJiBwcm9wLnR5cGUgPT09ICdMaXRlcmFsJyksXG4gICAgICAgICAgICBvcHRpb25hbDogZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIDogcHJvcFxuICAgIH1cblxuICAgIGFzc2VydChub2RlLCAnYWx3YXlzIGEgcmVzdWx0JylcbiAgICByZXN1bHQgPSBub2RlXG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ID1cbiAgICAgIGlzSWRlbnRpZmllck5hbWUobmFtZSkgJiYgIS9eW2Etel0vLnRlc3QobmFtZSlcbiAgICAgICAgPyB7dHlwZTogJ0lkZW50aWZpZXInLCBuYW1lfVxuICAgICAgICA6IHt0eXBlOiAnTGl0ZXJhbCcsIHZhbHVlOiBuYW1lfVxuICB9XG5cbiAgLy8gT25seSBsaXRlcmFscyBjYW4gYmUgcGFzc2VkIGluIGBjb21wb25lbnRzYCBjdXJyZW50bHkuXG4gIC8vIE5vIGlkZW50aWZpZXJzIC8gbWVtYmVyIGV4cHJlc3Npb25zLlxuICBpZiAocmVzdWx0LnR5cGUgPT09ICdMaXRlcmFsJykge1xuICAgIGNvbnN0IG5hbWUgPSAvKiogQHR5cGUge2tleW9mIEpTWC5JbnRyaW5zaWNFbGVtZW50c30gKi8gKHJlc3VsdC52YWx1ZSlcblxuICAgIHJldHVybiBvd24uY2FsbChzdGF0ZS5jb21wb25lbnRzLCBuYW1lKSA/IHN0YXRlLmNvbXBvbmVudHNbbmFtZV0gOiBuYW1lXG4gIH1cblxuICAvLyBBc3N1bWUgY29tcG9uZW50LlxuICBpZiAoc3RhdGUuZXZhbHVhdGVyKSB7XG4gICAgcmV0dXJuIHN0YXRlLmV2YWx1YXRlci5ldmFsdWF0ZUV4cHJlc3Npb24ocmVzdWx0KVxuICB9XG5cbiAgY3Jhc2hFc3RyZWUoc3RhdGUpXG59XG5cbi8qKlxuICogQHBhcmFtIHtTdGF0ZX0gc3RhdGVcbiAqIEBwYXJhbSB7UG9zaXRpb24gfCB1bmRlZmluZWR9IFtwbGFjZV1cbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZnVuY3Rpb24gY3Jhc2hFc3RyZWUoc3RhdGUsIHBsYWNlKSB7XG4gIGNvbnN0IG1lc3NhZ2UgPSBuZXcgVkZpbGVNZXNzYWdlKFxuICAgICdDYW5ub3QgaGFuZGxlIE1EWCBlc3RyZWVzIHdpdGhvdXQgYGNyZWF0ZUV2YWx1YXRlcmAnLFxuICAgIHtcbiAgICAgIGFuY2VzdG9yczogc3RhdGUuYW5jZXN0b3JzLFxuICAgICAgcGxhY2UsXG4gICAgICBydWxlSWQ6ICdtZHgtZXN0cmVlJyxcbiAgICAgIHNvdXJjZTogJ2hhc3QtdXRpbC10by1qc3gtcnVudGltZSdcbiAgICB9XG4gIClcbiAgbWVzc2FnZS5maWxlID0gc3RhdGUuZmlsZVBhdGggfHwgdW5kZWZpbmVkXG4gIG1lc3NhZ2UudXJsID0gZG9jcyArICcjY2Fubm90LWhhbmRsZS1tZHgtZXN0cmVlcy13aXRob3V0LWNyZWF0ZWV2YWx1YXRlcidcblxuICB0aHJvdyBtZXNzYWdlXG59XG5cbi8qKlxuICogVHJhbnNmb3JtIGEgRE9NIGNhc2luZyBzdHlsZSBvYmplY3QgdG8gYSBDU1MgY2FzaW5nIHN0eWxlIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge1N0eWxlfSBkb21DYXNpbmdcbiAqIEByZXR1cm5zIHtTdHlsZX1cbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtU3R5bGVzVG9Dc3NDYXNpbmcoZG9tQ2FzaW5nKSB7XG4gIC8qKiBAdHlwZSB7U3R5bGV9ICovXG4gIGNvbnN0IGNzc0Nhc2luZyA9IHt9XG4gIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICBsZXQgZnJvbVxuXG4gIGZvciAoZnJvbSBpbiBkb21DYXNpbmcpIHtcbiAgICBpZiAob3duLmNhbGwoZG9tQ2FzaW5nLCBmcm9tKSkge1xuICAgICAgY3NzQ2FzaW5nW3RyYW5zZm9ybVN0eWxlVG9Dc3NDYXNpbmcoZnJvbSldID0gZG9tQ2FzaW5nW2Zyb21dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNzc0Nhc2luZ1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybSBhIERPTSBjYXNpbmcgc3R5bGUgZmllbGQgdG8gYSBDU1MgY2FzaW5nIHN0eWxlIGZpZWxkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBmcm9tXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdHlsZVRvQ3NzQ2FzaW5nKGZyb20pIHtcbiAgbGV0IHRvID0gZnJvbS5yZXBsYWNlKGNhcCwgdG9EYXNoKVxuICAvLyBIYW5kbGUgYG1zLXh4eGAgLT4gYC1tcy14eHhgLlxuICBpZiAodG8uc2xpY2UoMCwgMykgPT09ICdtcy0nKSB0byA9ICctJyArIHRvXG4gIHJldHVybiB0b1xufVxuXG4vKipcbiAqIE1ha2UgYCQxYCBjYXBpdGFsaXplZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gX1xuICogICBXaGF0ZXZlci5cbiAqIEBwYXJhbSB7c3RyaW5nfSAkMVxuICogICBTaW5nbGUgQVNDSUkgYWxwaGFiZXRpY2FsLlxuICogQHJldHVybnMge3N0cmluZ31cbiAqICAgQ2FwaXRhbGl6ZWQgYCQxYC5cbiAqL1xuZnVuY3Rpb24gdG9DYW1lbChfLCAkMSkge1xuICByZXR1cm4gJDEudG9VcHBlckNhc2UoKVxufVxuXG4vKipcbiAqIE1ha2UgYCQwYCBkYXNoIGNhc2VkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSAkMFxuICogICBDYXBpdGFsaXplZCBBU0NJSSBsZXRlci5cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKiAgIERhc2ggYW5kIGxvd2VyIGxldHRlci5cbiAqL1xuZnVuY3Rpb24gdG9EYXNoKCQwKSB7XG4gIHJldHVybiAnLScgKyAkMC50b0xvd2VyQ2FzZSgpXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/hast-util-to-jsx-runtime/lib/index.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/hast-util-to-jsx-runtime/node_modules/style-to-object/esm/index.mjs":
/*!*******************************************************************************************!*\
  !*** ../node_modules/hast-util-to-jsx-runtime/node_modules/style-to-object/esm/index.mjs ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _cjs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../cjs/index.js */ \"(ssr)/../node_modules/hast-util-to-jsx-runtime/node_modules/style-to-object/cjs/index.js\");\n\n\n// ensure compatibility with rollup umd build\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_cjs_index_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] || _cjs_index_js__WEBPACK_IMPORTED_MODULE_0__);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2hhc3QtdXRpbC10by1qc3gtcnVudGltZS9ub2RlX21vZHVsZXMvc3R5bGUtdG8tb2JqZWN0L2VzbS9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBNEM7O0FBRTVDO0FBQ0EsaUVBQWUscURBQXFCLElBQUksMENBQWEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2dpdGh1Yl9teV9wb3J0Zm9saW8vLi4vbm9kZV9tb2R1bGVzL2hhc3QtdXRpbC10by1qc3gtcnVudGltZS9ub2RlX21vZHVsZXMvc3R5bGUtdG8tb2JqZWN0L2VzbS9pbmRleC5tanM/ODZiOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgU3R5bGVUb09iamVjdCBmcm9tICcuLi9janMvaW5kZXguanMnO1xuXG4vLyBlbnN1cmUgY29tcGF0aWJpbGl0eSB3aXRoIHJvbGx1cCB1bWQgYnVpbGRcbmV4cG9ydCBkZWZhdWx0IFN0eWxlVG9PYmplY3QuZGVmYXVsdCB8fCBTdHlsZVRvT2JqZWN0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/hast-util-to-jsx-runtime/node_modules/style-to-object/esm/index.mjs\n");

/***/ }),

/***/ "(rsc)/../node_modules/hast-util-to-jsx-runtime/lib/index.js":
/*!*************************************************************!*\
  !*** ../node_modules/hast-util-to-jsx-runtime/lib/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   toJsxRuntime: () => (/* binding */ toJsxRuntime)\n/* harmony export */ });\n/* harmony import */ var comma_separated_tokens__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! comma-separated-tokens */ \"(rsc)/../node_modules/comma-separated-tokens/index.js\");\n/* harmony import */ var devlop__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! devlop */ \"(rsc)/../node_modules/devlop/lib/development.js\");\n/* harmony import */ var estree_util_is_identifier_name__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! estree-util-is-identifier-name */ \"(rsc)/../node_modules/estree-util-is-identifier-name/lib/index.js\");\n/* harmony import */ var hast_util_whitespace__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! hast-util-whitespace */ \"(rsc)/../node_modules/hast-util-whitespace/lib/index.js\");\n/* harmony import */ var property_information__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! property-information */ \"(rsc)/../node_modules/property-information/index.js\");\n/* harmony import */ var property_information__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! property-information */ \"(rsc)/../node_modules/property-information/lib/find.js\");\n/* harmony import */ var property_information__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! property-information */ \"(rsc)/../node_modules/property-information/lib/hast-to-react.js\");\n/* harmony import */ var space_separated_tokens__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! space-separated-tokens */ \"(rsc)/../node_modules/space-separated-tokens/index.js\");\n/* harmony import */ var style_to_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! style-to-object */ \"(rsc)/../node_modules/hast-util-to-jsx-runtime/node_modules/style-to-object/esm/index.mjs\");\n/* harmony import */ var unist_util_position__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! unist-util-position */ \"(rsc)/../node_modules/unist-util-position/lib/index.js\");\n/* harmony import */ var vfile_message__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! vfile-message */ \"(rsc)/../node_modules/vfile-message/lib/index.js\");\n// Register MDX nodes in mdast:\n/// <reference types=\"mdast-util-mdx-expression\" />\n/// <reference types=\"mdast-util-mdx-jsx\" />\n/// <reference types=\"mdast-util-mdxjs-esm\" />\n\n/**\n * @typedef {import('estree').Identifier} Identifier\n * @typedef {import('estree').Literal} Literal\n * @typedef {import('estree').MemberExpression} MemberExpression\n * @typedef {import('estree').Expression} Expression\n * @typedef {import('estree').Program} Program\n *\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Nodes} Nodes\n * @typedef {import('hast').Parents} Parents\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Text} Text\n *\n * @typedef {import('mdast-util-mdx-expression').MdxFlowExpressionHast} MdxFlowExpression\n * @typedef {import('mdast-util-mdx-expression').MdxTextExpressionHast} MdxTextExpression\n *\n * @typedef {import('mdast-util-mdx-jsx').MdxJsxFlowElementHast} MdxJsxFlowElement\n * @typedef {import('mdast-util-mdx-jsx').MdxJsxTextElementHast} MdxJsxTextElement\n *\n * @typedef {import('mdast-util-mdxjs-esm').MdxjsEsmHast} MdxjsEsm\n *\n * @typedef {import('property-information').Schema} Schema\n *\n * @typedef {import('unist').Position} Position\n *\n * @typedef {import('./components.js').Components} Components\n */\n\n/**\n * @typedef {JSX.Element | string | null | undefined} Child\n *   Child.\n *\n * @callback Create\n *   Create something in development or production.\n * @param {Nodes} node\n *   hast node.\n * @param {unknown} type\n *   Fragment symbol or tag name.\n * @param {Props} props\n *   Properties and children.\n * @param {string | undefined} key\n *   Key.\n * @returns {JSX.Element}\n *   Result.\n *\n * @callback CreateEvaluater\n *   Create an evaluator that turns ESTree ASTs from embedded MDX into values.\n * @returns {Evaluater}\n *   Evaluater.\n *\n * @typedef {'html' | 'react'} ElementAttributeNameCase\n *   Casing to use for attribute names.\n *\n *   HTML casing is for example `class`, `stroke-linecap`, `xml:lang`.\n *   React casing is for example `className`, `strokeLinecap`, `xmlLang`.\n *\n * @callback EvaluateExpression\n *   Turn an MDX expression into a value.\n * @param {Expression} expression\n *   ESTree expression.\n * @returns {unknown}\n *   Result of expression.\n *\n * @callback EvaluateProgram\n *   Turn an MDX program (export/import statements) into a value.\n * @param {Program} expression\n *   ESTree program.\n * @returns {unknown}\n *   Result of program;\n *   should likely be `undefined` as ESM changes the scope but doesnâ€™t yield\n *   something.\n *\n * @typedef Evaluater\n *   Evaluator that turns ESTree ASTs from embedded MDX into values.\n * @property {EvaluateExpression} evaluateExpression\n *   Evaluate an expression.\n * @property {EvaluateProgram} evaluateProgram\n *   Evaluate a program.\n *\n * @typedef {[string, Value]} Field\n *   Property field.\n *\n * @typedef {unknown} Fragment\n *   Represent the children, typically a symbol.\n *\n * @callback Jsx\n *   Create a production element.\n * @param {unknown} type\n *   Element type: `Fragment` symbol, tag name (`string`), component.\n * @param {Props} props\n *   Element props, `children`, and maybe `node`.\n * @param {string | undefined} [key]\n *   Dynamicly generated key to use.\n * @returns {JSX.Element}\n *   Element from your framework.\n *\n * @callback JsxDev\n *   Create a development element.\n * @param {unknown} type\n *   Element type: `Fragment` symbol, tag name (`string`), component.\n * @param {Props} props\n *   Element props, `children`, and maybe `node`.\n * @param {string | undefined} key\n *   Dynamicly generated key to use.\n * @param {boolean} isStaticChildren\n *   Whether two or more children are passed (in an array), which is whether\n *   `jsxs` or `jsx` would be used.\n * @param {Source} source\n *   Info about source.\n * @param {undefined} self\n *   Nothing (this is used by frameworks that have components, we donâ€™t).\n * @returns {JSX.Element}\n *   Element from your framework.\n *\n * @typedef {{children?: Array<Child> | Child, node?: Element | MdxJsxFlowElement | MdxJsxTextElement | undefined, [prop: string]: Array<Child> | Child | Element | MdxJsxFlowElement | MdxJsxTextElement | Value | undefined}} Props\n *   Properties and children.\n *\n * @typedef RegularFields\n *   Configuration.\n * @property {Partial<Components> | null | undefined} [components]\n *   Components to use (optional).\n * @property {CreateEvaluater | null | undefined} [createEvaluater]\n *   Create an evaluator that turns ESTree ASTs into values (optional).\n * @property {ElementAttributeNameCase | null | undefined} [elementAttributeNameCase='react']\n *   Specify casing to use for attribute names (default: `'react'`).\n * @property {string | null | undefined} [filePath]\n *   File path to the original source file (optional).\n *\n *   Passed in source info to `jsxDEV` when using the automatic runtime with\n *   `development: true`.\n * @property {boolean | null | undefined} [ignoreInvalidStyle=false]\n *   Ignore invalid CSS in `style` props (default: `false`);\n *   the default behavior is to throw an error.\n * @property {boolean | null | undefined} [passKeys=true]\n *   Generate keys to optimize frameworks that support them (default: `true`).\n *\n *   > ðŸ‘‰ **Note**: Solid currently fails if keys are passed.\n * @property {boolean | null | undefined} [passNode=false]\n *   Pass the hast element node to components (default: `false`).\n * @property {Space | null | undefined} [space='html']\n *   Whether `tree` is in the `'html'` or `'svg'` space (default: `'html'`).\n *\n *   When an `<svg>` element is found in the HTML space, this package already\n *   automatically switches to and from the SVG space when entering and exiting\n *   it.\n * @property {StylePropertyNameCase | null | undefined} [stylePropertyNameCase='dom']\n *   Specify casing to use for property names in `style` objects (default:\n *   `'dom'`).\n * @property {boolean | null | undefined} [tableCellAlignToStyle=true]\n *   Turn obsolete `align` props on `td` and `th` into CSS `style` props\n *   (default: `true`).\n *\n * @typedef RuntimeDevelopment\n *   Runtime fields when development is on.\n * @property {Fragment} Fragment\n *   Fragment.\n * @property {true} development\n *   Whether to use `jsxDEV` (when on) or `jsx` and `jsxs` (when off).\n * @property {Jsx | null | undefined} [jsx]\n *   Dynamic JSX (optional).\n * @property {JsxDev} jsxDEV\n *   Development JSX.\n * @property {Jsx | null | undefined} [jsxs]\n *   Static JSX (optional).\n *\n * @typedef RuntimeProduction\n *   Runtime fields when development is off.\n * @property {Fragment} Fragment\n *   Fragment.\n * @property {false | null | undefined} [development]\n *   Whether to use `jsxDEV` (when on) or `jsx` and `jsxs` (when off) (optional).\n * @property {Jsx} jsx\n *   Dynamic JSX.\n * @property {JsxDev | null | undefined} [jsxDEV]\n *   Development JSX (optional).\n * @property {Jsx} jsxs\n *   Static JSX.\n *\n * @typedef RuntimeUnknown\n *   Runtime fields when development might be on or off.\n * @property {Fragment} Fragment\n *   Fragment.\n * @property {boolean} development\n *   Whether to use `jsxDEV` (when on) or `jsx` and `jsxs` (when off).\n * @property {Jsx | null | undefined} [jsx]\n *   Dynamic JSX (optional).\n * @property {JsxDev | null | undefined} [jsxDEV]\n *   Development JSX (optional).\n * @property {Jsx | null | undefined} [jsxs]\n *   Static JSX (optional).\n *\n * @typedef Source\n *   Info about source.\n * @property {number | undefined} columnNumber\n *   Column where thing starts (0-indexed).\n * @property {string | undefined} fileName\n *   Name of source file.\n * @property {number | undefined} lineNumber\n *   Line where thing starts (1-indexed).\n *\n * @typedef {'html' | 'svg'} Space\n *   Namespace.\n *\n *   > ðŸ‘‰ **Note**: hast is not XML.\n *   > It supports SVG as embedded in HTML.\n *   > It does not support the features available in XML.\n *   > Passing SVG might break but fragments of modern SVG should be fine.\n *   > Use `xast` if you need to support SVG as XML.\n *\n * @typedef State\n *   Info passed around.\n * @property {unknown} Fragment\n *   Fragment symbol.\n * @property {Array<Parents>} ancestors\n *   Stack of parents.\n * @property {Partial<Components>} components\n *   Components to swap.\n * @property {Create} create\n *   Create something in development or production.\n * @property {ElementAttributeNameCase} elementAttributeNameCase\n *   Casing to use for attribute names.\n * @property {Evaluater | undefined} evaluater\n *   Evaluator that turns ESTree ASTs into values.\n * @property {string | undefined} filePath\n *   File path.\n * @property {boolean} ignoreInvalidStyle\n *   Ignore invalid CSS in `style` props.\n * @property {boolean} passKeys\n *   Generate keys to optimize frameworks that support them.\n * @property {boolean} passNode\n *   Pass `node` to components.\n * @property {Schema} schema\n *   Current schema.\n * @property {StylePropertyNameCase} stylePropertyNameCase\n *   Casing to use for property names in `style` objects.\n * @property {boolean} tableCellAlignToStyle\n *   Turn obsolete `align` props on `td` and `th` into CSS `style` props.\n *\n * @typedef {Record<string, string>} Style\n *   Style map.\n *\n * @typedef {'css' | 'dom'} StylePropertyNameCase\n *   Casing to use for property names in `style` objects.\n *\n *   CSS casing is for example `background-color` and `-webkit-line-clamp`.\n *   DOM casing is for example `backgroundColor` and `WebkitLineClamp`.\n *\n * @typedef {Style | boolean | number | string} Value\n *   Primitive property value and `Style` map.\n */\n\n/**\n * @typedef {RuntimeDevelopment & RegularFields} Development\n *   Configuration (development).\n * @typedef {Development | Production | Unknown} Options\n *   Configuration.\n * @typedef {RegularFields & RuntimeProduction} Production\n *   Configuration (production).\n * @typedef {RegularFields & RuntimeUnknown} Unknown\n *   Configuration (production or development).\n */\n\n\n\n\n\n\n\n\n\n\n\nconst own = {}.hasOwnProperty\n\n/** @type {Map<string, number>} */\nconst emptyMap = new Map()\n\nconst cap = /[A-Z]/g\nconst dashSomething = /-([a-z])/g\n\n// `react-dom` triggers a warning for *any* white space in tables.\n// To follow GFM, `mdast-util-to-hast` injects line endings between elements.\n// Other tools might do so too, but they donâ€™t do here, so we remove all of\n// that.\n\n// See: <https://github.com/facebook/react/pull/7081>.\n// See: <https://github.com/facebook/react/pull/7515>.\n// See: <https://github.com/remarkjs/remark-react/issues/64>.\n// See: <https://github.com/rehypejs/rehype-react/pull/29>.\n// See: <https://github.com/rehypejs/rehype-react/pull/32>.\n// See: <https://github.com/rehypejs/rehype-react/pull/45>.\nconst tableElements = new Set(['table', 'tbody', 'thead', 'tfoot', 'tr'])\n\nconst tableCellElement = new Set(['td', 'th'])\n\nconst docs = 'https://github.com/syntax-tree/hast-util-to-jsx-runtime'\n\n/**\n * Transform a hast tree to preact, react, solid, svelte, vue, etc.,\n * with an automatic JSX runtime.\n *\n * @param {Nodes} tree\n *   Tree to transform.\n * @param {Options} options\n *   Configuration (required).\n * @returns {JSX.Element}\n *   JSX element.\n */\n\nfunction toJsxRuntime(tree, options) {\n  if (!options || options.Fragment === undefined) {\n    throw new TypeError('Expected `Fragment` in options')\n  }\n\n  const filePath = options.filePath || undefined\n  /** @type {Create} */\n  let create\n\n  if (options.development) {\n    if (typeof options.jsxDEV !== 'function') {\n      throw new TypeError(\n        'Expected `jsxDEV` in options when `development: true`'\n      )\n    }\n\n    create = developmentCreate(filePath, options.jsxDEV)\n  } else {\n    if (typeof options.jsx !== 'function') {\n      throw new TypeError('Expected `jsx` in production options')\n    }\n\n    if (typeof options.jsxs !== 'function') {\n      throw new TypeError('Expected `jsxs` in production options')\n    }\n\n    create = productionCreate(filePath, options.jsx, options.jsxs)\n  }\n\n  /** @type {State} */\n  const state = {\n    Fragment: options.Fragment,\n    ancestors: [],\n    components: options.components || {},\n    create,\n    elementAttributeNameCase: options.elementAttributeNameCase || 'react',\n    evaluater: options.createEvaluater ? options.createEvaluater() : undefined,\n    filePath,\n    ignoreInvalidStyle: options.ignoreInvalidStyle || false,\n    passKeys: options.passKeys !== false,\n    passNode: options.passNode || false,\n    schema: options.space === 'svg' ? property_information__WEBPACK_IMPORTED_MODULE_1__.svg : property_information__WEBPACK_IMPORTED_MODULE_1__.html,\n    stylePropertyNameCase: options.stylePropertyNameCase || 'dom',\n    tableCellAlignToStyle: options.tableCellAlignToStyle !== false\n  }\n\n  const result = one(state, tree, undefined)\n\n  // JSX element.\n  if (result && typeof result !== 'string') {\n    return result\n  }\n\n  // Text node or something that turned into nothing.\n  return state.create(\n    tree,\n    state.Fragment,\n    {children: result || undefined},\n    undefined\n  )\n}\n\n/**\n * Transform a node.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Nodes} node\n *   Current node.\n * @param {string | undefined} key\n *   Key.\n * @returns {Child | undefined}\n *   Child, optional.\n */\nfunction one(state, node, key) {\n  if (node.type === 'element') {\n    return element(state, node, key)\n  }\n\n  if (node.type === 'mdxFlowExpression' || node.type === 'mdxTextExpression') {\n    return mdxExpression(state, node)\n  }\n\n  if (node.type === 'mdxJsxFlowElement' || node.type === 'mdxJsxTextElement') {\n    return mdxJsxElement(state, node, key)\n  }\n\n  if (node.type === 'mdxjsEsm') {\n    return mdxEsm(state, node)\n  }\n\n  if (node.type === 'root') {\n    return root(state, node, key)\n  }\n\n  if (node.type === 'text') {\n    return text(state, node)\n  }\n}\n\n/**\n * Handle element.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Element} node\n *   Current node.\n * @param {string | undefined} key\n *   Key.\n * @returns {Child | undefined}\n *   Child, optional.\n */\nfunction element(state, node, key) {\n  const parentSchema = state.schema\n  let schema = parentSchema\n\n  if (node.tagName.toLowerCase() === 'svg' && parentSchema.space === 'html') {\n    schema = property_information__WEBPACK_IMPORTED_MODULE_1__.svg\n    state.schema = schema\n  }\n\n  state.ancestors.push(node)\n\n  const type = findComponentFromName(state, node.tagName, false)\n  const props = createElementProps(state, node)\n  let children = createChildren(state, node)\n\n  if (tableElements.has(node.tagName)) {\n    children = children.filter(function (child) {\n      return typeof child === 'string' ? !(0,hast_util_whitespace__WEBPACK_IMPORTED_MODULE_2__.whitespace)(child) : true\n    })\n  }\n\n  addNode(state, props, type, node)\n  addChildren(props, children)\n\n  // Restore.\n  state.ancestors.pop()\n  state.schema = parentSchema\n\n  return state.create(node, type, props, key)\n}\n\n/**\n * Handle MDX expression.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdxFlowExpression | MdxTextExpression} node\n *   Current node.\n * @returns {Child | undefined}\n *   Child, optional.\n */\nfunction mdxExpression(state, node) {\n  if (node.data && node.data.estree && state.evaluater) {\n    const program = node.data.estree\n    const expression = program.body[0]\n    ;(0,devlop__WEBPACK_IMPORTED_MODULE_3__.ok)(expression.type === 'ExpressionStatement')\n\n    // Assume result is a child.\n    return /** @type {Child | undefined} */ (\n      state.evaluater.evaluateExpression(expression.expression)\n    )\n  }\n\n  crashEstree(state, node.position)\n}\n\n/**\n * Handle MDX ESM.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdxjsEsm} node\n *   Current node.\n * @returns {Child | undefined}\n *   Child, optional.\n */\nfunction mdxEsm(state, node) {\n  if (node.data && node.data.estree && state.evaluater) {\n    // Assume result is a child.\n    return /** @type {Child | undefined} */ (\n      state.evaluater.evaluateProgram(node.data.estree)\n    )\n  }\n\n  crashEstree(state, node.position)\n}\n\n/**\n * Handle MDX JSX.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdxJsxFlowElement | MdxJsxTextElement} node\n *   Current node.\n * @param {string | undefined} key\n *   Key.\n * @returns {Child | undefined}\n *   Child, optional.\n */\nfunction mdxJsxElement(state, node, key) {\n  const parentSchema = state.schema\n  let schema = parentSchema\n\n  if (node.name === 'svg' && parentSchema.space === 'html') {\n    schema = property_information__WEBPACK_IMPORTED_MODULE_1__.svg\n    state.schema = schema\n  }\n\n  state.ancestors.push(node)\n\n  const type =\n    node.name === null\n      ? state.Fragment\n      : findComponentFromName(state, node.name, true)\n  const props = createJsxElementProps(state, node)\n  const children = createChildren(state, node)\n\n  addNode(state, props, type, node)\n  addChildren(props, children)\n\n  // Restore.\n  state.ancestors.pop()\n  state.schema = parentSchema\n\n  return state.create(node, type, props, key)\n}\n\n/**\n * Handle root.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Root} node\n *   Current node.\n * @param {string | undefined} key\n *   Key.\n * @returns {Child | undefined}\n *   Child, optional.\n */\nfunction root(state, node, key) {\n  /** @type {Props} */\n  const props = {}\n\n  addChildren(props, createChildren(state, node))\n\n  return state.create(node, state.Fragment, props, key)\n}\n\n/**\n * Handle text.\n *\n * @param {State} _\n *   Info passed around.\n * @param {Text} node\n *   Current node.\n * @returns {Child | undefined}\n *   Child, optional.\n */\nfunction text(_, node) {\n  return node.value\n}\n\n/**\n * Add `node` to props.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Props} props\n *   Props.\n * @param {unknown} type\n *   Type.\n * @param {Element | MdxJsxFlowElement | MdxJsxTextElement} node\n *   Node.\n * @returns {undefined}\n *   Nothing.\n */\nfunction addNode(state, props, type, node) {\n  // If this is swapped out for a component:\n  if (typeof type !== 'string' && type !== state.Fragment && state.passNode) {\n    props.node = node\n  }\n}\n\n/**\n * Add children to props.\n *\n * @param {Props} props\n *   Props.\n * @param {Array<Child>} children\n *   Children.\n * @returns {undefined}\n *   Nothing.\n */\nfunction addChildren(props, children) {\n  if (children.length > 0) {\n    const value = children.length > 1 ? children : children[0]\n\n    if (value) {\n      props.children = value\n    }\n  }\n}\n\n/**\n * @param {string | undefined} _\n *   Path to file.\n * @param {Jsx} jsx\n *   Dynamic.\n * @param {Jsx} jsxs\n *   Static.\n * @returns {Create}\n *   Create a production element.\n */\nfunction productionCreate(_, jsx, jsxs) {\n  return create\n  /** @type {Create} */\n  function create(_, type, props, key) {\n    // Only an array when there are 2 or more children.\n    const isStaticChildren = Array.isArray(props.children)\n    const fn = isStaticChildren ? jsxs : jsx\n    return key ? fn(type, props, key) : fn(type, props)\n  }\n}\n\n/**\n * @param {string | undefined} filePath\n *   Path to file.\n * @param {JsxDev} jsxDEV\n *   Development.\n * @returns {Create}\n *   Create a development element.\n */\nfunction developmentCreate(filePath, jsxDEV) {\n  return create\n  /** @type {Create} */\n  function create(node, type, props, key) {\n    // Only an array when there are 2 or more children.\n    const isStaticChildren = Array.isArray(props.children)\n    const point = (0,unist_util_position__WEBPACK_IMPORTED_MODULE_4__.pointStart)(node)\n    return jsxDEV(\n      type,\n      props,\n      key,\n      isStaticChildren,\n      {\n        columnNumber: point ? point.column - 1 : undefined,\n        fileName: filePath,\n        lineNumber: point ? point.line : undefined\n      },\n      undefined\n    )\n  }\n}\n\n/**\n * Create props from an element.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Element} node\n *   Current element.\n * @returns {Props}\n *   Props.\n */\nfunction createElementProps(state, node) {\n  /** @type {Props} */\n  const props = {}\n  /** @type {string | undefined} */\n  let alignValue\n  /** @type {string} */\n  let prop\n\n  for (prop in node.properties) {\n    if (prop !== 'children' && own.call(node.properties, prop)) {\n      const result = createProperty(state, prop, node.properties[prop])\n\n      if (result) {\n        const [key, value] = result\n\n        if (\n          state.tableCellAlignToStyle &&\n          key === 'align' &&\n          typeof value === 'string' &&\n          tableCellElement.has(node.tagName)\n        ) {\n          alignValue = value\n        } else {\n          props[key] = value\n        }\n      }\n    }\n  }\n\n  if (alignValue) {\n    // Assume style is an object.\n    const style = /** @type {Style} */ (props.style || (props.style = {}))\n    style[state.stylePropertyNameCase === 'css' ? 'text-align' : 'textAlign'] =\n      alignValue\n  }\n\n  return props\n}\n\n/**\n * Create props from a JSX element.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdxJsxFlowElement | MdxJsxTextElement} node\n *   Current JSX element.\n * @returns {Props}\n *   Props.\n */\nfunction createJsxElementProps(state, node) {\n  /** @type {Props} */\n  const props = {}\n\n  for (const attribute of node.attributes) {\n    if (attribute.type === 'mdxJsxExpressionAttribute') {\n      if (attribute.data && attribute.data.estree && state.evaluater) {\n        const program = attribute.data.estree\n        const expression = program.body[0]\n        ;(0,devlop__WEBPACK_IMPORTED_MODULE_3__.ok)(expression.type === 'ExpressionStatement')\n        const objectExpression = expression.expression\n        ;(0,devlop__WEBPACK_IMPORTED_MODULE_3__.ok)(objectExpression.type === 'ObjectExpression')\n        const property = objectExpression.properties[0]\n        ;(0,devlop__WEBPACK_IMPORTED_MODULE_3__.ok)(property.type === 'SpreadElement')\n\n        Object.assign(\n          props,\n          state.evaluater.evaluateExpression(property.argument)\n        )\n      } else {\n        crashEstree(state, node.position)\n      }\n    } else {\n      // For JSX, the author is responsible of passing in the correct values.\n      const name = attribute.name\n      /** @type {unknown} */\n      let value\n\n      if (attribute.value && typeof attribute.value === 'object') {\n        if (\n          attribute.value.data &&\n          attribute.value.data.estree &&\n          state.evaluater\n        ) {\n          const program = attribute.value.data.estree\n          const expression = program.body[0]\n          ;(0,devlop__WEBPACK_IMPORTED_MODULE_3__.ok)(expression.type === 'ExpressionStatement')\n          value = state.evaluater.evaluateExpression(expression.expression)\n        } else {\n          crashEstree(state, node.position)\n        }\n      } else {\n        value = attribute.value === null ? true : attribute.value\n      }\n\n      // Assume a prop.\n      props[name] = /** @type {Props[keyof Props]} */ (value)\n    }\n  }\n\n  return props\n}\n\n/**\n * Create children.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Parents} node\n *   Current element.\n * @returns {Array<Child>}\n *   Children.\n */\nfunction createChildren(state, node) {\n  /** @type {Array<Child>} */\n  const children = []\n  let index = -1\n  /** @type {Map<string, number>} */\n  // Note: test this when Solid doesnâ€™t want to merge my upcoming PR.\n  /* c8 ignore next */\n  const countsByName = state.passKeys ? new Map() : emptyMap\n\n  while (++index < node.children.length) {\n    const child = node.children[index]\n    /** @type {string | undefined} */\n    let key\n\n    if (state.passKeys) {\n      const name =\n        child.type === 'element'\n          ? child.tagName\n          : child.type === 'mdxJsxFlowElement' ||\n              child.type === 'mdxJsxTextElement'\n            ? child.name\n            : undefined\n\n      if (name) {\n        const count = countsByName.get(name) || 0\n        key = name + '-' + count\n        countsByName.set(name, count + 1)\n      }\n    }\n\n    const result = one(state, child, key)\n    if (result !== undefined) children.push(result)\n  }\n\n  return children\n}\n\n/**\n * Handle a property.\n *\n * @param {State} state\n *   Info passed around.\n * @param {string} prop\n *   Key.\n * @param {Array<number | string> | boolean | number | string | null | undefined} value\n *   hast property value.\n * @returns {Field | undefined}\n *   Field for runtime, optional.\n */\nfunction createProperty(state, prop, value) {\n  const info = (0,property_information__WEBPACK_IMPORTED_MODULE_5__.find)(state.schema, prop)\n\n  // Ignore nullish and `NaN` values.\n  if (\n    value === null ||\n    value === undefined ||\n    (typeof value === 'number' && Number.isNaN(value))\n  ) {\n    return\n  }\n\n  if (Array.isArray(value)) {\n    // Accept `array`.\n    // Most props are space-separated.\n    value = info.commaSeparated ? (0,comma_separated_tokens__WEBPACK_IMPORTED_MODULE_6__.stringify)(value) : (0,space_separated_tokens__WEBPACK_IMPORTED_MODULE_7__.stringify)(value)\n  }\n\n  // React only accepts `style` as object.\n  if (info.property === 'style') {\n    let styleObject =\n      typeof value === 'object' ? value : parseStyle(state, String(value))\n\n    if (state.stylePropertyNameCase === 'css') {\n      styleObject = transformStylesToCssCasing(styleObject)\n    }\n\n    return ['style', styleObject]\n  }\n\n  return [\n    state.elementAttributeNameCase === 'react' && info.space\n      ? property_information__WEBPACK_IMPORTED_MODULE_8__.hastToReact[info.property] || info.property\n      : info.attribute,\n    value\n  ]\n}\n\n/**\n * Parse a CSS declaration to an object.\n *\n * @param {State} state\n *   Info passed around.\n * @param {string} value\n *   CSS declarations.\n * @returns {Style}\n *   Properties.\n * @throws\n *   Throws `VFileMessage` when CSS cannot be parsed.\n */\nfunction parseStyle(state, value) {\n  /** @type {Style} */\n  const result = {}\n\n  try {\n    // @ts-expect-error: `style-to-object` types are broken.\n    ;(0,style_to_object__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(value, replacer)\n  } catch (error) {\n    if (!state.ignoreInvalidStyle) {\n      const cause = /** @type {Error} */ (error)\n      const message = new vfile_message__WEBPACK_IMPORTED_MODULE_9__.VFileMessage('Cannot parse `style` attribute', {\n        ancestors: state.ancestors,\n        cause,\n        ruleId: 'style',\n        source: 'hast-util-to-jsx-runtime'\n      })\n      message.file = state.filePath || undefined\n      message.url = docs + '#cannot-parse-style-attribute'\n\n      throw message\n    }\n  }\n\n  return result\n\n  /**\n   * Add a CSS property (normal, so with dashes) to `result` as a DOM CSS\n   * property.\n   *\n   * @param {string} name\n   *   Key.\n   * @param {string} value\n   *   Value\n   * @returns {undefined}\n   *   Nothing.\n   */\n  function replacer(name, value) {\n    let key = name\n\n    if (key.slice(0, 2) !== '--') {\n      if (key.slice(0, 4) === '-ms-') key = 'ms-' + key.slice(4)\n      key = key.replace(dashSomething, toCamel)\n    }\n\n    result[key] = value\n  }\n}\n\n/**\n * Create a JSX name from a string.\n *\n * @param {State} state\n *   To do.\n * @param {string} name\n *   Name.\n * @param {boolean} allowExpression\n *   Allow member expressions and identifiers.\n * @returns {unknown}\n *   To do.\n */\nfunction findComponentFromName(state, name, allowExpression) {\n  /** @type {Identifier | Literal | MemberExpression} */\n  let result\n\n  if (!allowExpression) {\n    result = {type: 'Literal', value: name}\n  } else if (name.includes('.')) {\n    const identifiers = name.split('.')\n    let index = -1\n    /** @type {Identifier | Literal | MemberExpression | undefined} */\n    let node\n\n    while (++index < identifiers.length) {\n      /** @type {Identifier | Literal} */\n      const prop = (0,estree_util_is_identifier_name__WEBPACK_IMPORTED_MODULE_10__.name)(identifiers[index])\n        ? {type: 'Identifier', name: identifiers[index]}\n        : {type: 'Literal', value: identifiers[index]}\n      node = node\n        ? {\n            type: 'MemberExpression',\n            object: node,\n            property: prop,\n            computed: Boolean(index && prop.type === 'Literal'),\n            optional: false\n          }\n        : prop\n    }\n\n    (0,devlop__WEBPACK_IMPORTED_MODULE_3__.ok)(node, 'always a result')\n    result = node\n  } else {\n    result =\n      (0,estree_util_is_identifier_name__WEBPACK_IMPORTED_MODULE_10__.name)(name) && !/^[a-z]/.test(name)\n        ? {type: 'Identifier', name}\n        : {type: 'Literal', value: name}\n  }\n\n  // Only literals can be passed in `components` currently.\n  // No identifiers / member expressions.\n  if (result.type === 'Literal') {\n    const name = /** @type {keyof JSX.IntrinsicElements} */ (result.value)\n\n    return own.call(state.components, name) ? state.components[name] : name\n  }\n\n  // Assume component.\n  if (state.evaluater) {\n    return state.evaluater.evaluateExpression(result)\n  }\n\n  crashEstree(state)\n}\n\n/**\n * @param {State} state\n * @param {Position | undefined} [place]\n * @returns {never}\n */\nfunction crashEstree(state, place) {\n  const message = new vfile_message__WEBPACK_IMPORTED_MODULE_9__.VFileMessage(\n    'Cannot handle MDX estrees without `createEvaluater`',\n    {\n      ancestors: state.ancestors,\n      place,\n      ruleId: 'mdx-estree',\n      source: 'hast-util-to-jsx-runtime'\n    }\n  )\n  message.file = state.filePath || undefined\n  message.url = docs + '#cannot-handle-mdx-estrees-without-createevaluater'\n\n  throw message\n}\n\n/**\n * Transform a DOM casing style object to a CSS casing style object.\n *\n * @param {Style} domCasing\n * @returns {Style}\n */\nfunction transformStylesToCssCasing(domCasing) {\n  /** @type {Style} */\n  const cssCasing = {}\n  /** @type {string} */\n  let from\n\n  for (from in domCasing) {\n    if (own.call(domCasing, from)) {\n      cssCasing[transformStyleToCssCasing(from)] = domCasing[from]\n    }\n  }\n\n  return cssCasing\n}\n\n/**\n * Transform a DOM casing style field to a CSS casing style field.\n *\n * @param {string} from\n * @returns {string}\n */\nfunction transformStyleToCssCasing(from) {\n  let to = from.replace(cap, toDash)\n  // Handle `ms-xxx` -> `-ms-xxx`.\n  if (to.slice(0, 3) === 'ms-') to = '-' + to\n  return to\n}\n\n/**\n * Make `$1` capitalized.\n *\n * @param {string} _\n *   Whatever.\n * @param {string} $1\n *   Single ASCII alphabetical.\n * @returns {string}\n *   Capitalized `$1`.\n */\nfunction toCamel(_, $1) {\n  return $1.toUpperCase()\n}\n\n/**\n * Make `$0` dash cased.\n *\n * @param {string} $0\n *   Capitalized ASCII leter.\n * @returns {string}\n *   Dash and lower letter.\n */\nfunction toDash($0) {\n  return '-' + $0.toLowerCase()\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2hhc3QtdXRpbC10by1qc3gtcnVudGltZS9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLDZCQUE2QjtBQUMxQyxhQUFhLDBCQUEwQjtBQUN2QyxhQUFhLG1DQUFtQztBQUNoRCxhQUFhLDZCQUE2QjtBQUMxQyxhQUFhLDBCQUEwQjtBQUN2QztBQUNBLGFBQWEsd0JBQXdCO0FBQ3JDLGFBQWEsc0JBQXNCO0FBQ25DLGFBQWEsd0JBQXdCO0FBQ3JDLGFBQWEscUJBQXFCO0FBQ2xDLGFBQWEscUJBQXFCO0FBQ2xDO0FBQ0EsYUFBYSwyREFBMkQ7QUFDeEUsYUFBYSwyREFBMkQ7QUFDeEU7QUFDQSxhQUFhLG9EQUFvRDtBQUNqRSxhQUFhLG9EQUFvRDtBQUNqRTtBQUNBLGFBQWEsNkNBQTZDO0FBQzFEO0FBQ0EsYUFBYSx1Q0FBdUM7QUFDcEQ7QUFDQSxhQUFhLDBCQUEwQjtBQUN2QztBQUNBLGFBQWEsc0NBQXNDO0FBQ25EOztBQUVBO0FBQ0EsYUFBYSx5Q0FBeUM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQSxXQUFXLG9CQUFvQjtBQUMvQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxvQkFBb0I7QUFDbEM7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQjtBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLFdBQVcsb0JBQW9CO0FBQy9CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsV0FBVyxvQkFBb0I7QUFDL0I7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFdBQVcsV0FBVztBQUN0QjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsY0FBYyxrTkFBa047QUFDaE87QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHdDQUF3QztBQUN0RDtBQUNBLGNBQWMsb0NBQW9DO0FBQ2xEO0FBQ0EsY0FBYyw2Q0FBNkM7QUFDM0Q7QUFDQSxjQUFjLDJCQUEyQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNEJBQTRCO0FBQzFDO0FBQ0E7QUFDQSxjQUFjLDRCQUE0QjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxjQUFjLDRCQUE0QjtBQUMxQztBQUNBLGNBQWMsMEJBQTBCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDBDQUEwQztBQUN4RDtBQUNBO0FBQ0EsY0FBYyw0QkFBNEI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsVUFBVTtBQUN4QjtBQUNBLGNBQWMsTUFBTTtBQUNwQjtBQUNBLGNBQWMsd0JBQXdCO0FBQ3RDO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0EsY0FBYyx3QkFBd0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFVBQVU7QUFDeEI7QUFDQSxjQUFjLDBCQUEwQjtBQUN4QztBQUNBLGNBQWMsS0FBSztBQUNuQjtBQUNBLGNBQWMsMkJBQTJCO0FBQ3pDO0FBQ0EsY0FBYyxLQUFLO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxVQUFVO0FBQ3hCO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0EsY0FBYyx3QkFBd0I7QUFDdEM7QUFDQSxjQUFjLDJCQUEyQjtBQUN6QztBQUNBLGNBQWMsd0JBQXdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxvQkFBb0I7QUFDbEM7QUFDQSxjQUFjLG9CQUFvQjtBQUNsQztBQUNBLGNBQWMsb0JBQW9CO0FBQ2xDO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBLGNBQWMsZ0JBQWdCO0FBQzlCO0FBQ0EsY0FBYyxxQkFBcUI7QUFDbkM7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQSxjQUFjLDBCQUEwQjtBQUN4QztBQUNBLGNBQWMsdUJBQXVCO0FBQ3JDO0FBQ0EsY0FBYyxvQkFBb0I7QUFDbEM7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQSxjQUFjLHVCQUF1QjtBQUNyQztBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0EsYUFBYSx3QkFBd0I7QUFDckM7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtQ0FBbUM7QUFDaEQ7QUFDQTs7QUFFQTtBQUNBLGFBQWEsb0NBQW9DO0FBQ2pEO0FBQ0EsYUFBYSxvQ0FBb0M7QUFDakQ7QUFDQSxhQUFhLG1DQUFtQztBQUNoRDtBQUNBLGFBQWEsZ0NBQWdDO0FBQzdDO0FBQ0E7O0FBRTBEO0FBQ3ZCO0FBQ29DO0FBQ3hCO0FBQ2tCO0FBQ1A7QUFDZjtBQUNHO0FBQ0o7O0FBRTFDLGNBQWM7O0FBRWQsV0FBVyxxQkFBcUI7QUFDaEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxxREFBRyxHQUFHLHNEQUFJO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssOEJBQThCO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQSxXQUFXLG9CQUFvQjtBQUMvQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBLFdBQVcsb0JBQW9CO0FBQy9CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLHFEQUFHO0FBQ2hCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEMsZ0VBQVU7QUFDcEQsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsV0FBVyx1Q0FBdUM7QUFDbEQ7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSwyQ0FBTTs7QUFFVjtBQUNBLHNCQUFzQixtQkFBbUI7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLFdBQVcsdUNBQXVDO0FBQ2xEO0FBQ0EsV0FBVyxvQkFBb0I7QUFDL0I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEscURBQUc7QUFDaEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQSxXQUFXLE1BQU07QUFDakI7QUFDQSxXQUFXLG9CQUFvQjtBQUMvQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQSxXQUFXLE1BQU07QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQSxXQUFXLGlEQUFpRDtBQUM1RDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLFdBQVcsY0FBYztBQUN6QjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLG9CQUFvQjtBQUMvQjtBQUNBLFdBQVcsS0FBSztBQUNoQjtBQUNBLFdBQVcsS0FBSztBQUNoQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsb0JBQW9CO0FBQy9CO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwrREFBVTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QixPQUFPLG9DQUFvQztBQUN4RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQSxXQUFXLHVDQUF1QztBQUNsRDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMkNBQU07QUFDZDtBQUNBLFFBQVEsMkNBQU07QUFDZDtBQUNBLFFBQVEsMkNBQU07O0FBRWQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsMkNBQU07QUFDaEI7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0EsK0JBQStCLG9CQUFvQjtBQUNuRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0EsYUFBYSxxQkFBcUI7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxXQUFXLHVFQUF1RTtBQUNsRjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlLDBEQUFJOztBQUVuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxpRUFBTSxVQUFVLGlFQUFNO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRLDZEQUFXO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQSxJQUFJLDREQUFhO0FBQ2pCLElBQUk7QUFDSjtBQUNBLCtCQUErQixPQUFPO0FBQ3RDLDBCQUEwQix1REFBWTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWEseUNBQXlDO0FBQ3REOztBQUVBO0FBQ0EsY0FBYztBQUNkLElBQUk7QUFDSjtBQUNBO0FBQ0EsZUFBZSxxREFBcUQ7QUFDcEU7O0FBRUE7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDLG1CQUFtQixxRUFBZ0I7QUFDbkMsV0FBVztBQUNYLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLDBDQUFNO0FBQ1Y7QUFDQSxJQUFJO0FBQ0o7QUFDQSxNQUFNLHFFQUFnQjtBQUN0QixXQUFXO0FBQ1gsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw2QkFBNkI7O0FBRXpEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLHNCQUFzQjtBQUNqQyxhQUFhO0FBQ2I7QUFDQTtBQUNBLHNCQUFzQix1REFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBLGFBQWEsUUFBUTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2dpdGh1Yl9teV9wb3J0Zm9saW8vLi4vbm9kZV9tb2R1bGVzL2hhc3QtdXRpbC10by1qc3gtcnVudGltZS9saWIvaW5kZXguanM/NGZlMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBSZWdpc3RlciBNRFggbm9kZXMgaW4gbWRhc3Q6XG4vLy8gPHJlZmVyZW5jZSB0eXBlcz1cIm1kYXN0LXV0aWwtbWR4LWV4cHJlc3Npb25cIiAvPlxuLy8vIDxyZWZlcmVuY2UgdHlwZXM9XCJtZGFzdC11dGlsLW1keC1qc3hcIiAvPlxuLy8vIDxyZWZlcmVuY2UgdHlwZXM9XCJtZGFzdC11dGlsLW1keGpzLWVzbVwiIC8+XG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnZXN0cmVlJykuSWRlbnRpZmllcn0gSWRlbnRpZmllclxuICogQHR5cGVkZWYge2ltcG9ydCgnZXN0cmVlJykuTGl0ZXJhbH0gTGl0ZXJhbFxuICogQHR5cGVkZWYge2ltcG9ydCgnZXN0cmVlJykuTWVtYmVyRXhwcmVzc2lvbn0gTWVtYmVyRXhwcmVzc2lvblxuICogQHR5cGVkZWYge2ltcG9ydCgnZXN0cmVlJykuRXhwcmVzc2lvbn0gRXhwcmVzc2lvblxuICogQHR5cGVkZWYge2ltcG9ydCgnZXN0cmVlJykuUHJvZ3JhbX0gUHJvZ3JhbVxuICpcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2hhc3QnKS5FbGVtZW50fSBFbGVtZW50XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdoYXN0JykuTm9kZXN9IE5vZGVzXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdoYXN0JykuUGFyZW50c30gUGFyZW50c1xuICogQHR5cGVkZWYge2ltcG9ydCgnaGFzdCcpLlJvb3R9IFJvb3RcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2hhc3QnKS5UZXh0fSBUZXh0XG4gKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QtdXRpbC1tZHgtZXhwcmVzc2lvbicpLk1keEZsb3dFeHByZXNzaW9uSGFzdH0gTWR4Rmxvd0V4cHJlc3Npb25cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0LXV0aWwtbWR4LWV4cHJlc3Npb24nKS5NZHhUZXh0RXhwcmVzc2lvbkhhc3R9IE1keFRleHRFeHByZXNzaW9uXG4gKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QtdXRpbC1tZHgtanN4JykuTWR4SnN4Rmxvd0VsZW1lbnRIYXN0fSBNZHhKc3hGbG93RWxlbWVudFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QtdXRpbC1tZHgtanN4JykuTWR4SnN4VGV4dEVsZW1lbnRIYXN0fSBNZHhKc3hUZXh0RWxlbWVudFxuICpcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0LXV0aWwtbWR4anMtZXNtJykuTWR4anNFc21IYXN0fSBNZHhqc0VzbVxuICpcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ3Byb3BlcnR5LWluZm9ybWF0aW9uJykuU2NoZW1hfSBTY2hlbWFcbiAqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCd1bmlzdCcpLlBvc2l0aW9ufSBQb3NpdGlvblxuICpcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vY29tcG9uZW50cy5qcycpLkNvbXBvbmVudHN9IENvbXBvbmVudHNcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtKU1guRWxlbWVudCB8IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWR9IENoaWxkXG4gKiAgIENoaWxkLlxuICpcbiAqIEBjYWxsYmFjayBDcmVhdGVcbiAqICAgQ3JlYXRlIHNvbWV0aGluZyBpbiBkZXZlbG9wbWVudCBvciBwcm9kdWN0aW9uLlxuICogQHBhcmFtIHtOb2Rlc30gbm9kZVxuICogICBoYXN0IG5vZGUuXG4gKiBAcGFyYW0ge3Vua25vd259IHR5cGVcbiAqICAgRnJhZ21lbnQgc3ltYm9sIG9yIHRhZyBuYW1lLlxuICogQHBhcmFtIHtQcm9wc30gcHJvcHNcbiAqICAgUHJvcGVydGllcyBhbmQgY2hpbGRyZW4uXG4gKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0ga2V5XG4gKiAgIEtleS5cbiAqIEByZXR1cm5zIHtKU1guRWxlbWVudH1cbiAqICAgUmVzdWx0LlxuICpcbiAqIEBjYWxsYmFjayBDcmVhdGVFdmFsdWF0ZXJcbiAqICAgQ3JlYXRlIGFuIGV2YWx1YXRvciB0aGF0IHR1cm5zIEVTVHJlZSBBU1RzIGZyb20gZW1iZWRkZWQgTURYIGludG8gdmFsdWVzLlxuICogQHJldHVybnMge0V2YWx1YXRlcn1cbiAqICAgRXZhbHVhdGVyLlxuICpcbiAqIEB0eXBlZGVmIHsnaHRtbCcgfCAncmVhY3QnfSBFbGVtZW50QXR0cmlidXRlTmFtZUNhc2VcbiAqICAgQ2FzaW5nIHRvIHVzZSBmb3IgYXR0cmlidXRlIG5hbWVzLlxuICpcbiAqICAgSFRNTCBjYXNpbmcgaXMgZm9yIGV4YW1wbGUgYGNsYXNzYCwgYHN0cm9rZS1saW5lY2FwYCwgYHhtbDpsYW5nYC5cbiAqICAgUmVhY3QgY2FzaW5nIGlzIGZvciBleGFtcGxlIGBjbGFzc05hbWVgLCBgc3Ryb2tlTGluZWNhcGAsIGB4bWxMYW5nYC5cbiAqXG4gKiBAY2FsbGJhY2sgRXZhbHVhdGVFeHByZXNzaW9uXG4gKiAgIFR1cm4gYW4gTURYIGV4cHJlc3Npb24gaW50byBhIHZhbHVlLlxuICogQHBhcmFtIHtFeHByZXNzaW9ufSBleHByZXNzaW9uXG4gKiAgIEVTVHJlZSBleHByZXNzaW9uLlxuICogQHJldHVybnMge3Vua25vd259XG4gKiAgIFJlc3VsdCBvZiBleHByZXNzaW9uLlxuICpcbiAqIEBjYWxsYmFjayBFdmFsdWF0ZVByb2dyYW1cbiAqICAgVHVybiBhbiBNRFggcHJvZ3JhbSAoZXhwb3J0L2ltcG9ydCBzdGF0ZW1lbnRzKSBpbnRvIGEgdmFsdWUuXG4gKiBAcGFyYW0ge1Byb2dyYW19IGV4cHJlc3Npb25cbiAqICAgRVNUcmVlIHByb2dyYW0uXG4gKiBAcmV0dXJucyB7dW5rbm93bn1cbiAqICAgUmVzdWx0IG9mIHByb2dyYW07XG4gKiAgIHNob3VsZCBsaWtlbHkgYmUgYHVuZGVmaW5lZGAgYXMgRVNNIGNoYW5nZXMgdGhlIHNjb3BlIGJ1dCBkb2VzbuKAmXQgeWllbGRcbiAqICAgc29tZXRoaW5nLlxuICpcbiAqIEB0eXBlZGVmIEV2YWx1YXRlclxuICogICBFdmFsdWF0b3IgdGhhdCB0dXJucyBFU1RyZWUgQVNUcyBmcm9tIGVtYmVkZGVkIE1EWCBpbnRvIHZhbHVlcy5cbiAqIEBwcm9wZXJ0eSB7RXZhbHVhdGVFeHByZXNzaW9ufSBldmFsdWF0ZUV4cHJlc3Npb25cbiAqICAgRXZhbHVhdGUgYW4gZXhwcmVzc2lvbi5cbiAqIEBwcm9wZXJ0eSB7RXZhbHVhdGVQcm9ncmFtfSBldmFsdWF0ZVByb2dyYW1cbiAqICAgRXZhbHVhdGUgYSBwcm9ncmFtLlxuICpcbiAqIEB0eXBlZGVmIHtbc3RyaW5nLCBWYWx1ZV19IEZpZWxkXG4gKiAgIFByb3BlcnR5IGZpZWxkLlxuICpcbiAqIEB0eXBlZGVmIHt1bmtub3dufSBGcmFnbWVudFxuICogICBSZXByZXNlbnQgdGhlIGNoaWxkcmVuLCB0eXBpY2FsbHkgYSBzeW1ib2wuXG4gKlxuICogQGNhbGxiYWNrIEpzeFxuICogICBDcmVhdGUgYSBwcm9kdWN0aW9uIGVsZW1lbnQuXG4gKiBAcGFyYW0ge3Vua25vd259IHR5cGVcbiAqICAgRWxlbWVudCB0eXBlOiBgRnJhZ21lbnRgIHN5bWJvbCwgdGFnIG5hbWUgKGBzdHJpbmdgKSwgY29tcG9uZW50LlxuICogQHBhcmFtIHtQcm9wc30gcHJvcHNcbiAqICAgRWxlbWVudCBwcm9wcywgYGNoaWxkcmVuYCwgYW5kIG1heWJlIGBub2RlYC5cbiAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBba2V5XVxuICogICBEeW5hbWljbHkgZ2VuZXJhdGVkIGtleSB0byB1c2UuXG4gKiBAcmV0dXJucyB7SlNYLkVsZW1lbnR9XG4gKiAgIEVsZW1lbnQgZnJvbSB5b3VyIGZyYW1ld29yay5cbiAqXG4gKiBAY2FsbGJhY2sgSnN4RGV2XG4gKiAgIENyZWF0ZSBhIGRldmVsb3BtZW50IGVsZW1lbnQuXG4gKiBAcGFyYW0ge3Vua25vd259IHR5cGVcbiAqICAgRWxlbWVudCB0eXBlOiBgRnJhZ21lbnRgIHN5bWJvbCwgdGFnIG5hbWUgKGBzdHJpbmdgKSwgY29tcG9uZW50LlxuICogQHBhcmFtIHtQcm9wc30gcHJvcHNcbiAqICAgRWxlbWVudCBwcm9wcywgYGNoaWxkcmVuYCwgYW5kIG1heWJlIGBub2RlYC5cbiAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBrZXlcbiAqICAgRHluYW1pY2x5IGdlbmVyYXRlZCBrZXkgdG8gdXNlLlxuICogQHBhcmFtIHtib29sZWFufSBpc1N0YXRpY0NoaWxkcmVuXG4gKiAgIFdoZXRoZXIgdHdvIG9yIG1vcmUgY2hpbGRyZW4gYXJlIHBhc3NlZCAoaW4gYW4gYXJyYXkpLCB3aGljaCBpcyB3aGV0aGVyXG4gKiAgIGBqc3hzYCBvciBganN4YCB3b3VsZCBiZSB1c2VkLlxuICogQHBhcmFtIHtTb3VyY2V9IHNvdXJjZVxuICogICBJbmZvIGFib3V0IHNvdXJjZS5cbiAqIEBwYXJhbSB7dW5kZWZpbmVkfSBzZWxmXG4gKiAgIE5vdGhpbmcgKHRoaXMgaXMgdXNlZCBieSBmcmFtZXdvcmtzIHRoYXQgaGF2ZSBjb21wb25lbnRzLCB3ZSBkb27igJl0KS5cbiAqIEByZXR1cm5zIHtKU1guRWxlbWVudH1cbiAqICAgRWxlbWVudCBmcm9tIHlvdXIgZnJhbWV3b3JrLlxuICpcbiAqIEB0eXBlZGVmIHt7Y2hpbGRyZW4/OiBBcnJheTxDaGlsZD4gfCBDaGlsZCwgbm9kZT86IEVsZW1lbnQgfCBNZHhKc3hGbG93RWxlbWVudCB8IE1keEpzeFRleHRFbGVtZW50IHwgdW5kZWZpbmVkLCBbcHJvcDogc3RyaW5nXTogQXJyYXk8Q2hpbGQ+IHwgQ2hpbGQgfCBFbGVtZW50IHwgTWR4SnN4Rmxvd0VsZW1lbnQgfCBNZHhKc3hUZXh0RWxlbWVudCB8IFZhbHVlIHwgdW5kZWZpbmVkfX0gUHJvcHNcbiAqICAgUHJvcGVydGllcyBhbmQgY2hpbGRyZW4uXG4gKlxuICogQHR5cGVkZWYgUmVndWxhckZpZWxkc1xuICogICBDb25maWd1cmF0aW9uLlxuICogQHByb3BlcnR5IHtQYXJ0aWFsPENvbXBvbmVudHM+IHwgbnVsbCB8IHVuZGVmaW5lZH0gW2NvbXBvbmVudHNdXG4gKiAgIENvbXBvbmVudHMgdG8gdXNlIChvcHRpb25hbCkuXG4gKiBAcHJvcGVydHkge0NyZWF0ZUV2YWx1YXRlciB8IG51bGwgfCB1bmRlZmluZWR9IFtjcmVhdGVFdmFsdWF0ZXJdXG4gKiAgIENyZWF0ZSBhbiBldmFsdWF0b3IgdGhhdCB0dXJucyBFU1RyZWUgQVNUcyBpbnRvIHZhbHVlcyAob3B0aW9uYWwpLlxuICogQHByb3BlcnR5IHtFbGVtZW50QXR0cmlidXRlTmFtZUNhc2UgfCBudWxsIHwgdW5kZWZpbmVkfSBbZWxlbWVudEF0dHJpYnV0ZU5hbWVDYXNlPSdyZWFjdCddXG4gKiAgIFNwZWNpZnkgY2FzaW5nIHRvIHVzZSBmb3IgYXR0cmlidXRlIG5hbWVzIChkZWZhdWx0OiBgJ3JlYWN0J2ApLlxuICogQHByb3BlcnR5IHtzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkfSBbZmlsZVBhdGhdXG4gKiAgIEZpbGUgcGF0aCB0byB0aGUgb3JpZ2luYWwgc291cmNlIGZpbGUgKG9wdGlvbmFsKS5cbiAqXG4gKiAgIFBhc3NlZCBpbiBzb3VyY2UgaW5mbyB0byBganN4REVWYCB3aGVuIHVzaW5nIHRoZSBhdXRvbWF0aWMgcnVudGltZSB3aXRoXG4gKiAgIGBkZXZlbG9wbWVudDogdHJ1ZWAuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW4gfCBudWxsIHwgdW5kZWZpbmVkfSBbaWdub3JlSW52YWxpZFN0eWxlPWZhbHNlXVxuICogICBJZ25vcmUgaW52YWxpZCBDU1MgaW4gYHN0eWxlYCBwcm9wcyAoZGVmYXVsdDogYGZhbHNlYCk7XG4gKiAgIHRoZSBkZWZhdWx0IGJlaGF2aW9yIGlzIHRvIHRocm93IGFuIGVycm9yLlxuICogQHByb3BlcnR5IHtib29sZWFuIHwgbnVsbCB8IHVuZGVmaW5lZH0gW3Bhc3NLZXlzPXRydWVdXG4gKiAgIEdlbmVyYXRlIGtleXMgdG8gb3B0aW1pemUgZnJhbWV3b3JrcyB0aGF0IHN1cHBvcnQgdGhlbSAoZGVmYXVsdDogYHRydWVgKS5cbiAqXG4gKiAgID4g8J+RiSAqKk5vdGUqKjogU29saWQgY3VycmVudGx5IGZhaWxzIGlmIGtleXMgYXJlIHBhc3NlZC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbiB8IG51bGwgfCB1bmRlZmluZWR9IFtwYXNzTm9kZT1mYWxzZV1cbiAqICAgUGFzcyB0aGUgaGFzdCBlbGVtZW50IG5vZGUgdG8gY29tcG9uZW50cyAoZGVmYXVsdDogYGZhbHNlYCkuXG4gKiBAcHJvcGVydHkge1NwYWNlIHwgbnVsbCB8IHVuZGVmaW5lZH0gW3NwYWNlPSdodG1sJ11cbiAqICAgV2hldGhlciBgdHJlZWAgaXMgaW4gdGhlIGAnaHRtbCdgIG9yIGAnc3ZnJ2Agc3BhY2UgKGRlZmF1bHQ6IGAnaHRtbCdgKS5cbiAqXG4gKiAgIFdoZW4gYW4gYDxzdmc+YCBlbGVtZW50IGlzIGZvdW5kIGluIHRoZSBIVE1MIHNwYWNlLCB0aGlzIHBhY2thZ2UgYWxyZWFkeVxuICogICBhdXRvbWF0aWNhbGx5IHN3aXRjaGVzIHRvIGFuZCBmcm9tIHRoZSBTVkcgc3BhY2Ugd2hlbiBlbnRlcmluZyBhbmQgZXhpdGluZ1xuICogICBpdC5cbiAqIEBwcm9wZXJ0eSB7U3R5bGVQcm9wZXJ0eU5hbWVDYXNlIHwgbnVsbCB8IHVuZGVmaW5lZH0gW3N0eWxlUHJvcGVydHlOYW1lQ2FzZT0nZG9tJ11cbiAqICAgU3BlY2lmeSBjYXNpbmcgdG8gdXNlIGZvciBwcm9wZXJ0eSBuYW1lcyBpbiBgc3R5bGVgIG9iamVjdHMgKGRlZmF1bHQ6XG4gKiAgIGAnZG9tJ2ApLlxuICogQHByb3BlcnR5IHtib29sZWFuIHwgbnVsbCB8IHVuZGVmaW5lZH0gW3RhYmxlQ2VsbEFsaWduVG9TdHlsZT10cnVlXVxuICogICBUdXJuIG9ic29sZXRlIGBhbGlnbmAgcHJvcHMgb24gYHRkYCBhbmQgYHRoYCBpbnRvIENTUyBgc3R5bGVgIHByb3BzXG4gKiAgIChkZWZhdWx0OiBgdHJ1ZWApLlxuICpcbiAqIEB0eXBlZGVmIFJ1bnRpbWVEZXZlbG9wbWVudFxuICogICBSdW50aW1lIGZpZWxkcyB3aGVuIGRldmVsb3BtZW50IGlzIG9uLlxuICogQHByb3BlcnR5IHtGcmFnbWVudH0gRnJhZ21lbnRcbiAqICAgRnJhZ21lbnQuXG4gKiBAcHJvcGVydHkge3RydWV9IGRldmVsb3BtZW50XG4gKiAgIFdoZXRoZXIgdG8gdXNlIGBqc3hERVZgICh3aGVuIG9uKSBvciBganN4YCBhbmQgYGpzeHNgICh3aGVuIG9mZikuXG4gKiBAcHJvcGVydHkge0pzeCB8IG51bGwgfCB1bmRlZmluZWR9IFtqc3hdXG4gKiAgIER5bmFtaWMgSlNYIChvcHRpb25hbCkuXG4gKiBAcHJvcGVydHkge0pzeERldn0ganN4REVWXG4gKiAgIERldmVsb3BtZW50IEpTWC5cbiAqIEBwcm9wZXJ0eSB7SnN4IHwgbnVsbCB8IHVuZGVmaW5lZH0gW2pzeHNdXG4gKiAgIFN0YXRpYyBKU1ggKG9wdGlvbmFsKS5cbiAqXG4gKiBAdHlwZWRlZiBSdW50aW1lUHJvZHVjdGlvblxuICogICBSdW50aW1lIGZpZWxkcyB3aGVuIGRldmVsb3BtZW50IGlzIG9mZi5cbiAqIEBwcm9wZXJ0eSB7RnJhZ21lbnR9IEZyYWdtZW50XG4gKiAgIEZyYWdtZW50LlxuICogQHByb3BlcnR5IHtmYWxzZSB8IG51bGwgfCB1bmRlZmluZWR9IFtkZXZlbG9wbWVudF1cbiAqICAgV2hldGhlciB0byB1c2UgYGpzeERFVmAgKHdoZW4gb24pIG9yIGBqc3hgIGFuZCBganN4c2AgKHdoZW4gb2ZmKSAob3B0aW9uYWwpLlxuICogQHByb3BlcnR5IHtKc3h9IGpzeFxuICogICBEeW5hbWljIEpTWC5cbiAqIEBwcm9wZXJ0eSB7SnN4RGV2IHwgbnVsbCB8IHVuZGVmaW5lZH0gW2pzeERFVl1cbiAqICAgRGV2ZWxvcG1lbnQgSlNYIChvcHRpb25hbCkuXG4gKiBAcHJvcGVydHkge0pzeH0ganN4c1xuICogICBTdGF0aWMgSlNYLlxuICpcbiAqIEB0eXBlZGVmIFJ1bnRpbWVVbmtub3duXG4gKiAgIFJ1bnRpbWUgZmllbGRzIHdoZW4gZGV2ZWxvcG1lbnQgbWlnaHQgYmUgb24gb3Igb2ZmLlxuICogQHByb3BlcnR5IHtGcmFnbWVudH0gRnJhZ21lbnRcbiAqICAgRnJhZ21lbnQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGRldmVsb3BtZW50XG4gKiAgIFdoZXRoZXIgdG8gdXNlIGBqc3hERVZgICh3aGVuIG9uKSBvciBganN4YCBhbmQgYGpzeHNgICh3aGVuIG9mZikuXG4gKiBAcHJvcGVydHkge0pzeCB8IG51bGwgfCB1bmRlZmluZWR9IFtqc3hdXG4gKiAgIER5bmFtaWMgSlNYIChvcHRpb25hbCkuXG4gKiBAcHJvcGVydHkge0pzeERldiB8IG51bGwgfCB1bmRlZmluZWR9IFtqc3hERVZdXG4gKiAgIERldmVsb3BtZW50IEpTWCAob3B0aW9uYWwpLlxuICogQHByb3BlcnR5IHtKc3ggfCBudWxsIHwgdW5kZWZpbmVkfSBbanN4c11cbiAqICAgU3RhdGljIEpTWCAob3B0aW9uYWwpLlxuICpcbiAqIEB0eXBlZGVmIFNvdXJjZVxuICogICBJbmZvIGFib3V0IHNvdXJjZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyIHwgdW5kZWZpbmVkfSBjb2x1bW5OdW1iZXJcbiAqICAgQ29sdW1uIHdoZXJlIHRoaW5nIHN0YXJ0cyAoMC1pbmRleGVkKS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBmaWxlTmFtZVxuICogICBOYW1lIG9mIHNvdXJjZSBmaWxlLlxuICogQHByb3BlcnR5IHtudW1iZXIgfCB1bmRlZmluZWR9IGxpbmVOdW1iZXJcbiAqICAgTGluZSB3aGVyZSB0aGluZyBzdGFydHMgKDEtaW5kZXhlZCkuXG4gKlxuICogQHR5cGVkZWYgeydodG1sJyB8ICdzdmcnfSBTcGFjZVxuICogICBOYW1lc3BhY2UuXG4gKlxuICogICA+IPCfkYkgKipOb3RlKio6IGhhc3QgaXMgbm90IFhNTC5cbiAqICAgPiBJdCBzdXBwb3J0cyBTVkcgYXMgZW1iZWRkZWQgaW4gSFRNTC5cbiAqICAgPiBJdCBkb2VzIG5vdCBzdXBwb3J0IHRoZSBmZWF0dXJlcyBhdmFpbGFibGUgaW4gWE1MLlxuICogICA+IFBhc3NpbmcgU1ZHIG1pZ2h0IGJyZWFrIGJ1dCBmcmFnbWVudHMgb2YgbW9kZXJuIFNWRyBzaG91bGQgYmUgZmluZS5cbiAqICAgPiBVc2UgYHhhc3RgIGlmIHlvdSBuZWVkIHRvIHN1cHBvcnQgU1ZHIGFzIFhNTC5cbiAqXG4gKiBAdHlwZWRlZiBTdGF0ZVxuICogICBJbmZvIHBhc3NlZCBhcm91bmQuXG4gKiBAcHJvcGVydHkge3Vua25vd259IEZyYWdtZW50XG4gKiAgIEZyYWdtZW50IHN5bWJvbC5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8UGFyZW50cz59IGFuY2VzdG9yc1xuICogICBTdGFjayBvZiBwYXJlbnRzLlxuICogQHByb3BlcnR5IHtQYXJ0aWFsPENvbXBvbmVudHM+fSBjb21wb25lbnRzXG4gKiAgIENvbXBvbmVudHMgdG8gc3dhcC5cbiAqIEBwcm9wZXJ0eSB7Q3JlYXRlfSBjcmVhdGVcbiAqICAgQ3JlYXRlIHNvbWV0aGluZyBpbiBkZXZlbG9wbWVudCBvciBwcm9kdWN0aW9uLlxuICogQHByb3BlcnR5IHtFbGVtZW50QXR0cmlidXRlTmFtZUNhc2V9IGVsZW1lbnRBdHRyaWJ1dGVOYW1lQ2FzZVxuICogICBDYXNpbmcgdG8gdXNlIGZvciBhdHRyaWJ1dGUgbmFtZXMuXG4gKiBAcHJvcGVydHkge0V2YWx1YXRlciB8IHVuZGVmaW5lZH0gZXZhbHVhdGVyXG4gKiAgIEV2YWx1YXRvciB0aGF0IHR1cm5zIEVTVHJlZSBBU1RzIGludG8gdmFsdWVzLlxuICogQHByb3BlcnR5IHtzdHJpbmcgfCB1bmRlZmluZWR9IGZpbGVQYXRoXG4gKiAgIEZpbGUgcGF0aC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaWdub3JlSW52YWxpZFN0eWxlXG4gKiAgIElnbm9yZSBpbnZhbGlkIENTUyBpbiBgc3R5bGVgIHByb3BzLlxuICogQHByb3BlcnR5IHtib29sZWFufSBwYXNzS2V5c1xuICogICBHZW5lcmF0ZSBrZXlzIHRvIG9wdGltaXplIGZyYW1ld29ya3MgdGhhdCBzdXBwb3J0IHRoZW0uXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHBhc3NOb2RlXG4gKiAgIFBhc3MgYG5vZGVgIHRvIGNvbXBvbmVudHMuXG4gKiBAcHJvcGVydHkge1NjaGVtYX0gc2NoZW1hXG4gKiAgIEN1cnJlbnQgc2NoZW1hLlxuICogQHByb3BlcnR5IHtTdHlsZVByb3BlcnR5TmFtZUNhc2V9IHN0eWxlUHJvcGVydHlOYW1lQ2FzZVxuICogICBDYXNpbmcgdG8gdXNlIGZvciBwcm9wZXJ0eSBuYW1lcyBpbiBgc3R5bGVgIG9iamVjdHMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHRhYmxlQ2VsbEFsaWduVG9TdHlsZVxuICogICBUdXJuIG9ic29sZXRlIGBhbGlnbmAgcHJvcHMgb24gYHRkYCBhbmQgYHRoYCBpbnRvIENTUyBgc3R5bGVgIHByb3BzLlxuICpcbiAqIEB0eXBlZGVmIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+fSBTdHlsZVxuICogICBTdHlsZSBtYXAuXG4gKlxuICogQHR5cGVkZWYgeydjc3MnIHwgJ2RvbSd9IFN0eWxlUHJvcGVydHlOYW1lQ2FzZVxuICogICBDYXNpbmcgdG8gdXNlIGZvciBwcm9wZXJ0eSBuYW1lcyBpbiBgc3R5bGVgIG9iamVjdHMuXG4gKlxuICogICBDU1MgY2FzaW5nIGlzIGZvciBleGFtcGxlIGBiYWNrZ3JvdW5kLWNvbG9yYCBhbmQgYC13ZWJraXQtbGluZS1jbGFtcGAuXG4gKiAgIERPTSBjYXNpbmcgaXMgZm9yIGV4YW1wbGUgYGJhY2tncm91bmRDb2xvcmAgYW5kIGBXZWJraXRMaW5lQ2xhbXBgLlxuICpcbiAqIEB0eXBlZGVmIHtTdHlsZSB8IGJvb2xlYW4gfCBudW1iZXIgfCBzdHJpbmd9IFZhbHVlXG4gKiAgIFByaW1pdGl2ZSBwcm9wZXJ0eSB2YWx1ZSBhbmQgYFN0eWxlYCBtYXAuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7UnVudGltZURldmVsb3BtZW50ICYgUmVndWxhckZpZWxkc30gRGV2ZWxvcG1lbnRcbiAqICAgQ29uZmlndXJhdGlvbiAoZGV2ZWxvcG1lbnQpLlxuICogQHR5cGVkZWYge0RldmVsb3BtZW50IHwgUHJvZHVjdGlvbiB8IFVua25vd259IE9wdGlvbnNcbiAqICAgQ29uZmlndXJhdGlvbi5cbiAqIEB0eXBlZGVmIHtSZWd1bGFyRmllbGRzICYgUnVudGltZVByb2R1Y3Rpb259IFByb2R1Y3Rpb25cbiAqICAgQ29uZmlndXJhdGlvbiAocHJvZHVjdGlvbikuXG4gKiBAdHlwZWRlZiB7UmVndWxhckZpZWxkcyAmIFJ1bnRpbWVVbmtub3dufSBVbmtub3duXG4gKiAgIENvbmZpZ3VyYXRpb24gKHByb2R1Y3Rpb24gb3IgZGV2ZWxvcG1lbnQpLlxuICovXG5cbmltcG9ydCB7c3RyaW5naWZ5IGFzIGNvbW1hc30gZnJvbSAnY29tbWEtc2VwYXJhdGVkLXRva2VucydcbmltcG9ydCB7b2sgYXMgYXNzZXJ0fSBmcm9tICdkZXZsb3AnXG5pbXBvcnQge25hbWUgYXMgaXNJZGVudGlmaWVyTmFtZX0gZnJvbSAnZXN0cmVlLXV0aWwtaXMtaWRlbnRpZmllci1uYW1lJ1xuaW1wb3J0IHt3aGl0ZXNwYWNlfSBmcm9tICdoYXN0LXV0aWwtd2hpdGVzcGFjZSdcbmltcG9ydCB7ZmluZCwgaGFzdFRvUmVhY3QsIGh0bWwsIHN2Z30gZnJvbSAncHJvcGVydHktaW5mb3JtYXRpb24nXG5pbXBvcnQge3N0cmluZ2lmeSBhcyBzcGFjZXN9IGZyb20gJ3NwYWNlLXNlcGFyYXRlZC10b2tlbnMnXG5pbXBvcnQgc3R5bGVUb09iamVjdCBmcm9tICdzdHlsZS10by1vYmplY3QnXG5pbXBvcnQge3BvaW50U3RhcnR9IGZyb20gJ3VuaXN0LXV0aWwtcG9zaXRpb24nXG5pbXBvcnQge1ZGaWxlTWVzc2FnZX0gZnJvbSAndmZpbGUtbWVzc2FnZSdcblxuY29uc3Qgb3duID0ge30uaGFzT3duUHJvcGVydHlcblxuLyoqIEB0eXBlIHtNYXA8c3RyaW5nLCBudW1iZXI+fSAqL1xuY29uc3QgZW1wdHlNYXAgPSBuZXcgTWFwKClcblxuY29uc3QgY2FwID0gL1tBLVpdL2dcbmNvbnN0IGRhc2hTb21ldGhpbmcgPSAvLShbYS16XSkvZ1xuXG4vLyBgcmVhY3QtZG9tYCB0cmlnZ2VycyBhIHdhcm5pbmcgZm9yICphbnkqIHdoaXRlIHNwYWNlIGluIHRhYmxlcy5cbi8vIFRvIGZvbGxvdyBHRk0sIGBtZGFzdC11dGlsLXRvLWhhc3RgIGluamVjdHMgbGluZSBlbmRpbmdzIGJldHdlZW4gZWxlbWVudHMuXG4vLyBPdGhlciB0b29scyBtaWdodCBkbyBzbyB0b28sIGJ1dCB0aGV5IGRvbuKAmXQgZG8gaGVyZSwgc28gd2UgcmVtb3ZlIGFsbCBvZlxuLy8gdGhhdC5cblxuLy8gU2VlOiA8aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvNzA4MT4uXG4vLyBTZWU6IDxodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC83NTE1Pi5cbi8vIFNlZTogPGh0dHBzOi8vZ2l0aHViLmNvbS9yZW1hcmtqcy9yZW1hcmstcmVhY3QvaXNzdWVzLzY0Pi5cbi8vIFNlZTogPGh0dHBzOi8vZ2l0aHViLmNvbS9yZWh5cGVqcy9yZWh5cGUtcmVhY3QvcHVsbC8yOT4uXG4vLyBTZWU6IDxodHRwczovL2dpdGh1Yi5jb20vcmVoeXBlanMvcmVoeXBlLXJlYWN0L3B1bGwvMzI+LlxuLy8gU2VlOiA8aHR0cHM6Ly9naXRodWIuY29tL3JlaHlwZWpzL3JlaHlwZS1yZWFjdC9wdWxsLzQ1Pi5cbmNvbnN0IHRhYmxlRWxlbWVudHMgPSBuZXcgU2V0KFsndGFibGUnLCAndGJvZHknLCAndGhlYWQnLCAndGZvb3QnLCAndHInXSlcblxuY29uc3QgdGFibGVDZWxsRWxlbWVudCA9IG5ldyBTZXQoWyd0ZCcsICd0aCddKVxuXG5jb25zdCBkb2NzID0gJ2h0dHBzOi8vZ2l0aHViLmNvbS9zeW50YXgtdHJlZS9oYXN0LXV0aWwtdG8tanN4LXJ1bnRpbWUnXG5cbi8qKlxuICogVHJhbnNmb3JtIGEgaGFzdCB0cmVlIHRvIHByZWFjdCwgcmVhY3QsIHNvbGlkLCBzdmVsdGUsIHZ1ZSwgZXRjLixcbiAqIHdpdGggYW4gYXV0b21hdGljIEpTWCBydW50aW1lLlxuICpcbiAqIEBwYXJhbSB7Tm9kZXN9IHRyZWVcbiAqICAgVHJlZSB0byB0cmFuc2Zvcm0uXG4gKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnNcbiAqICAgQ29uZmlndXJhdGlvbiAocmVxdWlyZWQpLlxuICogQHJldHVybnMge0pTWC5FbGVtZW50fVxuICogICBKU1ggZWxlbWVudC5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdG9Kc3hSdW50aW1lKHRyZWUsIG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zIHx8IG9wdGlvbnMuRnJhZ21lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGBGcmFnbWVudGAgaW4gb3B0aW9ucycpXG4gIH1cblxuICBjb25zdCBmaWxlUGF0aCA9IG9wdGlvbnMuZmlsZVBhdGggfHwgdW5kZWZpbmVkXG4gIC8qKiBAdHlwZSB7Q3JlYXRlfSAqL1xuICBsZXQgY3JlYXRlXG5cbiAgaWYgKG9wdGlvbnMuZGV2ZWxvcG1lbnQpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuanN4REVWICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnRXhwZWN0ZWQgYGpzeERFVmAgaW4gb3B0aW9ucyB3aGVuIGBkZXZlbG9wbWVudDogdHJ1ZWAnXG4gICAgICApXG4gICAgfVxuXG4gICAgY3JlYXRlID0gZGV2ZWxvcG1lbnRDcmVhdGUoZmlsZVBhdGgsIG9wdGlvbnMuanN4REVWKVxuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5qc3ggIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGBqc3hgIGluIHByb2R1Y3Rpb24gb3B0aW9ucycpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmpzeHMgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGBqc3hzYCBpbiBwcm9kdWN0aW9uIG9wdGlvbnMnKVxuICAgIH1cblxuICAgIGNyZWF0ZSA9IHByb2R1Y3Rpb25DcmVhdGUoZmlsZVBhdGgsIG9wdGlvbnMuanN4LCBvcHRpb25zLmpzeHMpXG4gIH1cblxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuICBjb25zdCBzdGF0ZSA9IHtcbiAgICBGcmFnbWVudDogb3B0aW9ucy5GcmFnbWVudCxcbiAgICBhbmNlc3RvcnM6IFtdLFxuICAgIGNvbXBvbmVudHM6IG9wdGlvbnMuY29tcG9uZW50cyB8fCB7fSxcbiAgICBjcmVhdGUsXG4gICAgZWxlbWVudEF0dHJpYnV0ZU5hbWVDYXNlOiBvcHRpb25zLmVsZW1lbnRBdHRyaWJ1dGVOYW1lQ2FzZSB8fCAncmVhY3QnLFxuICAgIGV2YWx1YXRlcjogb3B0aW9ucy5jcmVhdGVFdmFsdWF0ZXIgPyBvcHRpb25zLmNyZWF0ZUV2YWx1YXRlcigpIDogdW5kZWZpbmVkLFxuICAgIGZpbGVQYXRoLFxuICAgIGlnbm9yZUludmFsaWRTdHlsZTogb3B0aW9ucy5pZ25vcmVJbnZhbGlkU3R5bGUgfHwgZmFsc2UsXG4gICAgcGFzc0tleXM6IG9wdGlvbnMucGFzc0tleXMgIT09IGZhbHNlLFxuICAgIHBhc3NOb2RlOiBvcHRpb25zLnBhc3NOb2RlIHx8IGZhbHNlLFxuICAgIHNjaGVtYTogb3B0aW9ucy5zcGFjZSA9PT0gJ3N2ZycgPyBzdmcgOiBodG1sLFxuICAgIHN0eWxlUHJvcGVydHlOYW1lQ2FzZTogb3B0aW9ucy5zdHlsZVByb3BlcnR5TmFtZUNhc2UgfHwgJ2RvbScsXG4gICAgdGFibGVDZWxsQWxpZ25Ub1N0eWxlOiBvcHRpb25zLnRhYmxlQ2VsbEFsaWduVG9TdHlsZSAhPT0gZmFsc2VcbiAgfVxuXG4gIGNvbnN0IHJlc3VsdCA9IG9uZShzdGF0ZSwgdHJlZSwgdW5kZWZpbmVkKVxuXG4gIC8vIEpTWCBlbGVtZW50LlxuICBpZiAocmVzdWx0ICYmIHR5cGVvZiByZXN1bHQgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgLy8gVGV4dCBub2RlIG9yIHNvbWV0aGluZyB0aGF0IHR1cm5lZCBpbnRvIG5vdGhpbmcuXG4gIHJldHVybiBzdGF0ZS5jcmVhdGUoXG4gICAgdHJlZSxcbiAgICBzdGF0ZS5GcmFnbWVudCxcbiAgICB7Y2hpbGRyZW46IHJlc3VsdCB8fCB1bmRlZmluZWR9LFxuICAgIHVuZGVmaW5lZFxuICApXG59XG5cbi8qKlxuICogVHJhbnNmb3JtIGEgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZVxuICogICBJbmZvIHBhc3NlZCBhcm91bmQuXG4gKiBAcGFyYW0ge05vZGVzfSBub2RlXG4gKiAgIEN1cnJlbnQgbm9kZS5cbiAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBrZXlcbiAqICAgS2V5LlxuICogQHJldHVybnMge0NoaWxkIHwgdW5kZWZpbmVkfVxuICogICBDaGlsZCwgb3B0aW9uYWwuXG4gKi9cbmZ1bmN0aW9uIG9uZShzdGF0ZSwgbm9kZSwga2V5KSB7XG4gIGlmIChub2RlLnR5cGUgPT09ICdlbGVtZW50Jykge1xuICAgIHJldHVybiBlbGVtZW50KHN0YXRlLCBub2RlLCBrZXkpXG4gIH1cblxuICBpZiAobm9kZS50eXBlID09PSAnbWR4Rmxvd0V4cHJlc3Npb24nIHx8IG5vZGUudHlwZSA9PT0gJ21keFRleHRFeHByZXNzaW9uJykge1xuICAgIHJldHVybiBtZHhFeHByZXNzaW9uKHN0YXRlLCBub2RlKVxuICB9XG5cbiAgaWYgKG5vZGUudHlwZSA9PT0gJ21keEpzeEZsb3dFbGVtZW50JyB8fCBub2RlLnR5cGUgPT09ICdtZHhKc3hUZXh0RWxlbWVudCcpIHtcbiAgICByZXR1cm4gbWR4SnN4RWxlbWVudChzdGF0ZSwgbm9kZSwga2V5KVxuICB9XG5cbiAgaWYgKG5vZGUudHlwZSA9PT0gJ21keGpzRXNtJykge1xuICAgIHJldHVybiBtZHhFc20oc3RhdGUsIG5vZGUpXG4gIH1cblxuICBpZiAobm9kZS50eXBlID09PSAncm9vdCcpIHtcbiAgICByZXR1cm4gcm9vdChzdGF0ZSwgbm9kZSwga2V5KVxuICB9XG5cbiAgaWYgKG5vZGUudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgcmV0dXJuIHRleHQoc3RhdGUsIG5vZGUpXG4gIH1cbn1cblxuLyoqXG4gKiBIYW5kbGUgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZVxuICogICBJbmZvIHBhc3NlZCBhcm91bmQuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGVcbiAqICAgQ3VycmVudCBub2RlLlxuICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IGtleVxuICogICBLZXkuXG4gKiBAcmV0dXJucyB7Q2hpbGQgfCB1bmRlZmluZWR9XG4gKiAgIENoaWxkLCBvcHRpb25hbC5cbiAqL1xuZnVuY3Rpb24gZWxlbWVudChzdGF0ZSwgbm9kZSwga2V5KSB7XG4gIGNvbnN0IHBhcmVudFNjaGVtYSA9IHN0YXRlLnNjaGVtYVxuICBsZXQgc2NoZW1hID0gcGFyZW50U2NoZW1hXG5cbiAgaWYgKG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnc3ZnJyAmJiBwYXJlbnRTY2hlbWEuc3BhY2UgPT09ICdodG1sJykge1xuICAgIHNjaGVtYSA9IHN2Z1xuICAgIHN0YXRlLnNjaGVtYSA9IHNjaGVtYVxuICB9XG5cbiAgc3RhdGUuYW5jZXN0b3JzLnB1c2gobm9kZSlcblxuICBjb25zdCB0eXBlID0gZmluZENvbXBvbmVudEZyb21OYW1lKHN0YXRlLCBub2RlLnRhZ05hbWUsIGZhbHNlKVxuICBjb25zdCBwcm9wcyA9IGNyZWF0ZUVsZW1lbnRQcm9wcyhzdGF0ZSwgbm9kZSlcbiAgbGV0IGNoaWxkcmVuID0gY3JlYXRlQ2hpbGRyZW4oc3RhdGUsIG5vZGUpXG5cbiAgaWYgKHRhYmxlRWxlbWVudHMuaGFzKG5vZGUudGFnTmFtZSkpIHtcbiAgICBjaGlsZHJlbiA9IGNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgY2hpbGQgPT09ICdzdHJpbmcnID8gIXdoaXRlc3BhY2UoY2hpbGQpIDogdHJ1ZVxuICAgIH0pXG4gIH1cblxuICBhZGROb2RlKHN0YXRlLCBwcm9wcywgdHlwZSwgbm9kZSlcbiAgYWRkQ2hpbGRyZW4ocHJvcHMsIGNoaWxkcmVuKVxuXG4gIC8vIFJlc3RvcmUuXG4gIHN0YXRlLmFuY2VzdG9ycy5wb3AoKVxuICBzdGF0ZS5zY2hlbWEgPSBwYXJlbnRTY2hlbWFcblxuICByZXR1cm4gc3RhdGUuY3JlYXRlKG5vZGUsIHR5cGUsIHByb3BzLCBrZXkpXG59XG5cbi8qKlxuICogSGFuZGxlIE1EWCBleHByZXNzaW9uLlxuICpcbiAqIEBwYXJhbSB7U3RhdGV9IHN0YXRlXG4gKiAgIEluZm8gcGFzc2VkIGFyb3VuZC5cbiAqIEBwYXJhbSB7TWR4Rmxvd0V4cHJlc3Npb24gfCBNZHhUZXh0RXhwcmVzc2lvbn0gbm9kZVxuICogICBDdXJyZW50IG5vZGUuXG4gKiBAcmV0dXJucyB7Q2hpbGQgfCB1bmRlZmluZWR9XG4gKiAgIENoaWxkLCBvcHRpb25hbC5cbiAqL1xuZnVuY3Rpb24gbWR4RXhwcmVzc2lvbihzdGF0ZSwgbm9kZSkge1xuICBpZiAobm9kZS5kYXRhICYmIG5vZGUuZGF0YS5lc3RyZWUgJiYgc3RhdGUuZXZhbHVhdGVyKSB7XG4gICAgY29uc3QgcHJvZ3JhbSA9IG5vZGUuZGF0YS5lc3RyZWVcbiAgICBjb25zdCBleHByZXNzaW9uID0gcHJvZ3JhbS5ib2R5WzBdXG4gICAgYXNzZXJ0KGV4cHJlc3Npb24udHlwZSA9PT0gJ0V4cHJlc3Npb25TdGF0ZW1lbnQnKVxuXG4gICAgLy8gQXNzdW1lIHJlc3VsdCBpcyBhIGNoaWxkLlxuICAgIHJldHVybiAvKiogQHR5cGUge0NoaWxkIHwgdW5kZWZpbmVkfSAqLyAoXG4gICAgICBzdGF0ZS5ldmFsdWF0ZXIuZXZhbHVhdGVFeHByZXNzaW9uKGV4cHJlc3Npb24uZXhwcmVzc2lvbilcbiAgICApXG4gIH1cblxuICBjcmFzaEVzdHJlZShzdGF0ZSwgbm9kZS5wb3NpdGlvbilcbn1cblxuLyoqXG4gKiBIYW5kbGUgTURYIEVTTS5cbiAqXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZVxuICogICBJbmZvIHBhc3NlZCBhcm91bmQuXG4gKiBAcGFyYW0ge01keGpzRXNtfSBub2RlXG4gKiAgIEN1cnJlbnQgbm9kZS5cbiAqIEByZXR1cm5zIHtDaGlsZCB8IHVuZGVmaW5lZH1cbiAqICAgQ2hpbGQsIG9wdGlvbmFsLlxuICovXG5mdW5jdGlvbiBtZHhFc20oc3RhdGUsIG5vZGUpIHtcbiAgaWYgKG5vZGUuZGF0YSAmJiBub2RlLmRhdGEuZXN0cmVlICYmIHN0YXRlLmV2YWx1YXRlcikge1xuICAgIC8vIEFzc3VtZSByZXN1bHQgaXMgYSBjaGlsZC5cbiAgICByZXR1cm4gLyoqIEB0eXBlIHtDaGlsZCB8IHVuZGVmaW5lZH0gKi8gKFxuICAgICAgc3RhdGUuZXZhbHVhdGVyLmV2YWx1YXRlUHJvZ3JhbShub2RlLmRhdGEuZXN0cmVlKVxuICAgIClcbiAgfVxuXG4gIGNyYXNoRXN0cmVlKHN0YXRlLCBub2RlLnBvc2l0aW9uKVxufVxuXG4vKipcbiAqIEhhbmRsZSBNRFggSlNYLlxuICpcbiAqIEBwYXJhbSB7U3RhdGV9IHN0YXRlXG4gKiAgIEluZm8gcGFzc2VkIGFyb3VuZC5cbiAqIEBwYXJhbSB7TWR4SnN4Rmxvd0VsZW1lbnQgfCBNZHhKc3hUZXh0RWxlbWVudH0gbm9kZVxuICogICBDdXJyZW50IG5vZGUuXG4gKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0ga2V5XG4gKiAgIEtleS5cbiAqIEByZXR1cm5zIHtDaGlsZCB8IHVuZGVmaW5lZH1cbiAqICAgQ2hpbGQsIG9wdGlvbmFsLlxuICovXG5mdW5jdGlvbiBtZHhKc3hFbGVtZW50KHN0YXRlLCBub2RlLCBrZXkpIHtcbiAgY29uc3QgcGFyZW50U2NoZW1hID0gc3RhdGUuc2NoZW1hXG4gIGxldCBzY2hlbWEgPSBwYXJlbnRTY2hlbWFcblxuICBpZiAobm9kZS5uYW1lID09PSAnc3ZnJyAmJiBwYXJlbnRTY2hlbWEuc3BhY2UgPT09ICdodG1sJykge1xuICAgIHNjaGVtYSA9IHN2Z1xuICAgIHN0YXRlLnNjaGVtYSA9IHNjaGVtYVxuICB9XG5cbiAgc3RhdGUuYW5jZXN0b3JzLnB1c2gobm9kZSlcblxuICBjb25zdCB0eXBlID1cbiAgICBub2RlLm5hbWUgPT09IG51bGxcbiAgICAgID8gc3RhdGUuRnJhZ21lbnRcbiAgICAgIDogZmluZENvbXBvbmVudEZyb21OYW1lKHN0YXRlLCBub2RlLm5hbWUsIHRydWUpXG4gIGNvbnN0IHByb3BzID0gY3JlYXRlSnN4RWxlbWVudFByb3BzKHN0YXRlLCBub2RlKVxuICBjb25zdCBjaGlsZHJlbiA9IGNyZWF0ZUNoaWxkcmVuKHN0YXRlLCBub2RlKVxuXG4gIGFkZE5vZGUoc3RhdGUsIHByb3BzLCB0eXBlLCBub2RlKVxuICBhZGRDaGlsZHJlbihwcm9wcywgY2hpbGRyZW4pXG5cbiAgLy8gUmVzdG9yZS5cbiAgc3RhdGUuYW5jZXN0b3JzLnBvcCgpXG4gIHN0YXRlLnNjaGVtYSA9IHBhcmVudFNjaGVtYVxuXG4gIHJldHVybiBzdGF0ZS5jcmVhdGUobm9kZSwgdHlwZSwgcHJvcHMsIGtleSlcbn1cblxuLyoqXG4gKiBIYW5kbGUgcm9vdC5cbiAqXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZVxuICogICBJbmZvIHBhc3NlZCBhcm91bmQuXG4gKiBAcGFyYW0ge1Jvb3R9IG5vZGVcbiAqICAgQ3VycmVudCBub2RlLlxuICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IGtleVxuICogICBLZXkuXG4gKiBAcmV0dXJucyB7Q2hpbGQgfCB1bmRlZmluZWR9XG4gKiAgIENoaWxkLCBvcHRpb25hbC5cbiAqL1xuZnVuY3Rpb24gcm9vdChzdGF0ZSwgbm9kZSwga2V5KSB7XG4gIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gIGNvbnN0IHByb3BzID0ge31cblxuICBhZGRDaGlsZHJlbihwcm9wcywgY3JlYXRlQ2hpbGRyZW4oc3RhdGUsIG5vZGUpKVxuXG4gIHJldHVybiBzdGF0ZS5jcmVhdGUobm9kZSwgc3RhdGUuRnJhZ21lbnQsIHByb3BzLCBrZXkpXG59XG5cbi8qKlxuICogSGFuZGxlIHRleHQuXG4gKlxuICogQHBhcmFtIHtTdGF0ZX0gX1xuICogICBJbmZvIHBhc3NlZCBhcm91bmQuXG4gKiBAcGFyYW0ge1RleHR9IG5vZGVcbiAqICAgQ3VycmVudCBub2RlLlxuICogQHJldHVybnMge0NoaWxkIHwgdW5kZWZpbmVkfVxuICogICBDaGlsZCwgb3B0aW9uYWwuXG4gKi9cbmZ1bmN0aW9uIHRleHQoXywgbm9kZSkge1xuICByZXR1cm4gbm9kZS52YWx1ZVxufVxuXG4vKipcbiAqIEFkZCBgbm9kZWAgdG8gcHJvcHMuXG4gKlxuICogQHBhcmFtIHtTdGF0ZX0gc3RhdGVcbiAqICAgSW5mbyBwYXNzZWQgYXJvdW5kLlxuICogQHBhcmFtIHtQcm9wc30gcHJvcHNcbiAqICAgUHJvcHMuXG4gKiBAcGFyYW0ge3Vua25vd259IHR5cGVcbiAqICAgVHlwZS5cbiAqIEBwYXJhbSB7RWxlbWVudCB8IE1keEpzeEZsb3dFbGVtZW50IHwgTWR4SnN4VGV4dEVsZW1lbnR9IG5vZGVcbiAqICAgTm9kZS5cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiAgIE5vdGhpbmcuXG4gKi9cbmZ1bmN0aW9uIGFkZE5vZGUoc3RhdGUsIHByb3BzLCB0eXBlLCBub2RlKSB7XG4gIC8vIElmIHRoaXMgaXMgc3dhcHBlZCBvdXQgZm9yIGEgY29tcG9uZW50OlxuICBpZiAodHlwZW9mIHR5cGUgIT09ICdzdHJpbmcnICYmIHR5cGUgIT09IHN0YXRlLkZyYWdtZW50ICYmIHN0YXRlLnBhc3NOb2RlKSB7XG4gICAgcHJvcHMubm9kZSA9IG5vZGVcbiAgfVxufVxuXG4vKipcbiAqIEFkZCBjaGlsZHJlbiB0byBwcm9wcy5cbiAqXG4gKiBAcGFyYW0ge1Byb3BzfSBwcm9wc1xuICogICBQcm9wcy5cbiAqIEBwYXJhbSB7QXJyYXk8Q2hpbGQ+fSBjaGlsZHJlblxuICogICBDaGlsZHJlbi5cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiAgIE5vdGhpbmcuXG4gKi9cbmZ1bmN0aW9uIGFkZENoaWxkcmVuKHByb3BzLCBjaGlsZHJlbikge1xuICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IHZhbHVlID0gY2hpbGRyZW4ubGVuZ3RoID4gMSA/IGNoaWxkcmVuIDogY2hpbGRyZW5bMF1cblxuICAgIGlmICh2YWx1ZSkge1xuICAgICAgcHJvcHMuY2hpbGRyZW4gPSB2YWx1ZVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBfXG4gKiAgIFBhdGggdG8gZmlsZS5cbiAqIEBwYXJhbSB7SnN4fSBqc3hcbiAqICAgRHluYW1pYy5cbiAqIEBwYXJhbSB7SnN4fSBqc3hzXG4gKiAgIFN0YXRpYy5cbiAqIEByZXR1cm5zIHtDcmVhdGV9XG4gKiAgIENyZWF0ZSBhIHByb2R1Y3Rpb24gZWxlbWVudC5cbiAqL1xuZnVuY3Rpb24gcHJvZHVjdGlvbkNyZWF0ZShfLCBqc3gsIGpzeHMpIHtcbiAgcmV0dXJuIGNyZWF0ZVxuICAvKiogQHR5cGUge0NyZWF0ZX0gKi9cbiAgZnVuY3Rpb24gY3JlYXRlKF8sIHR5cGUsIHByb3BzLCBrZXkpIHtcbiAgICAvLyBPbmx5IGFuIGFycmF5IHdoZW4gdGhlcmUgYXJlIDIgb3IgbW9yZSBjaGlsZHJlbi5cbiAgICBjb25zdCBpc1N0YXRpY0NoaWxkcmVuID0gQXJyYXkuaXNBcnJheShwcm9wcy5jaGlsZHJlbilcbiAgICBjb25zdCBmbiA9IGlzU3RhdGljQ2hpbGRyZW4gPyBqc3hzIDoganN4XG4gICAgcmV0dXJuIGtleSA/IGZuKHR5cGUsIHByb3BzLCBrZXkpIDogZm4odHlwZSwgcHJvcHMpXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gZmlsZVBhdGhcbiAqICAgUGF0aCB0byBmaWxlLlxuICogQHBhcmFtIHtKc3hEZXZ9IGpzeERFVlxuICogICBEZXZlbG9wbWVudC5cbiAqIEByZXR1cm5zIHtDcmVhdGV9XG4gKiAgIENyZWF0ZSBhIGRldmVsb3BtZW50IGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIGRldmVsb3BtZW50Q3JlYXRlKGZpbGVQYXRoLCBqc3hERVYpIHtcbiAgcmV0dXJuIGNyZWF0ZVxuICAvKiogQHR5cGUge0NyZWF0ZX0gKi9cbiAgZnVuY3Rpb24gY3JlYXRlKG5vZGUsIHR5cGUsIHByb3BzLCBrZXkpIHtcbiAgICAvLyBPbmx5IGFuIGFycmF5IHdoZW4gdGhlcmUgYXJlIDIgb3IgbW9yZSBjaGlsZHJlbi5cbiAgICBjb25zdCBpc1N0YXRpY0NoaWxkcmVuID0gQXJyYXkuaXNBcnJheShwcm9wcy5jaGlsZHJlbilcbiAgICBjb25zdCBwb2ludCA9IHBvaW50U3RhcnQobm9kZSlcbiAgICByZXR1cm4ganN4REVWKFxuICAgICAgdHlwZSxcbiAgICAgIHByb3BzLFxuICAgICAga2V5LFxuICAgICAgaXNTdGF0aWNDaGlsZHJlbixcbiAgICAgIHtcbiAgICAgICAgY29sdW1uTnVtYmVyOiBwb2ludCA/IHBvaW50LmNvbHVtbiAtIDEgOiB1bmRlZmluZWQsXG4gICAgICAgIGZpbGVOYW1lOiBmaWxlUGF0aCxcbiAgICAgICAgbGluZU51bWJlcjogcG9pbnQgPyBwb2ludC5saW5lIDogdW5kZWZpbmVkXG4gICAgICB9LFxuICAgICAgdW5kZWZpbmVkXG4gICAgKVxuICB9XG59XG5cbi8qKlxuICogQ3JlYXRlIHByb3BzIGZyb20gYW4gZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZVxuICogICBJbmZvIHBhc3NlZCBhcm91bmQuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGVcbiAqICAgQ3VycmVudCBlbGVtZW50LlxuICogQHJldHVybnMge1Byb3BzfVxuICogICBQcm9wcy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRWxlbWVudFByb3BzKHN0YXRlLCBub2RlKSB7XG4gIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gIGNvbnN0IHByb3BzID0ge31cbiAgLyoqIEB0eXBlIHtzdHJpbmcgfCB1bmRlZmluZWR9ICovXG4gIGxldCBhbGlnblZhbHVlXG4gIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICBsZXQgcHJvcFxuXG4gIGZvciAocHJvcCBpbiBub2RlLnByb3BlcnRpZXMpIHtcbiAgICBpZiAocHJvcCAhPT0gJ2NoaWxkcmVuJyAmJiBvd24uY2FsbChub2RlLnByb3BlcnRpZXMsIHByb3ApKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBjcmVhdGVQcm9wZXJ0eShzdGF0ZSwgcHJvcCwgbm9kZS5wcm9wZXJ0aWVzW3Byb3BdKVxuXG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIGNvbnN0IFtrZXksIHZhbHVlXSA9IHJlc3VsdFxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICBzdGF0ZS50YWJsZUNlbGxBbGlnblRvU3R5bGUgJiZcbiAgICAgICAgICBrZXkgPT09ICdhbGlnbicgJiZcbiAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgdGFibGVDZWxsRWxlbWVudC5oYXMobm9kZS50YWdOYW1lKVxuICAgICAgICApIHtcbiAgICAgICAgICBhbGlnblZhbHVlID0gdmFsdWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9wc1trZXldID0gdmFsdWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChhbGlnblZhbHVlKSB7XG4gICAgLy8gQXNzdW1lIHN0eWxlIGlzIGFuIG9iamVjdC5cbiAgICBjb25zdCBzdHlsZSA9IC8qKiBAdHlwZSB7U3R5bGV9ICovIChwcm9wcy5zdHlsZSB8fCAocHJvcHMuc3R5bGUgPSB7fSkpXG4gICAgc3R5bGVbc3RhdGUuc3R5bGVQcm9wZXJ0eU5hbWVDYXNlID09PSAnY3NzJyA/ICd0ZXh0LWFsaWduJyA6ICd0ZXh0QWxpZ24nXSA9XG4gICAgICBhbGlnblZhbHVlXG4gIH1cblxuICByZXR1cm4gcHJvcHNcbn1cblxuLyoqXG4gKiBDcmVhdGUgcHJvcHMgZnJvbSBhIEpTWCBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7U3RhdGV9IHN0YXRlXG4gKiAgIEluZm8gcGFzc2VkIGFyb3VuZC5cbiAqIEBwYXJhbSB7TWR4SnN4Rmxvd0VsZW1lbnQgfCBNZHhKc3hUZXh0RWxlbWVudH0gbm9kZVxuICogICBDdXJyZW50IEpTWCBlbGVtZW50LlxuICogQHJldHVybnMge1Byb3BzfVxuICogICBQcm9wcy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSnN4RWxlbWVudFByb3BzKHN0YXRlLCBub2RlKSB7XG4gIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gIGNvbnN0IHByb3BzID0ge31cblxuICBmb3IgKGNvbnN0IGF0dHJpYnV0ZSBvZiBub2RlLmF0dHJpYnV0ZXMpIHtcbiAgICBpZiAoYXR0cmlidXRlLnR5cGUgPT09ICdtZHhKc3hFeHByZXNzaW9uQXR0cmlidXRlJykge1xuICAgICAgaWYgKGF0dHJpYnV0ZS5kYXRhICYmIGF0dHJpYnV0ZS5kYXRhLmVzdHJlZSAmJiBzdGF0ZS5ldmFsdWF0ZXIpIHtcbiAgICAgICAgY29uc3QgcHJvZ3JhbSA9IGF0dHJpYnV0ZS5kYXRhLmVzdHJlZVxuICAgICAgICBjb25zdCBleHByZXNzaW9uID0gcHJvZ3JhbS5ib2R5WzBdXG4gICAgICAgIGFzc2VydChleHByZXNzaW9uLnR5cGUgPT09ICdFeHByZXNzaW9uU3RhdGVtZW50JylcbiAgICAgICAgY29uc3Qgb2JqZWN0RXhwcmVzc2lvbiA9IGV4cHJlc3Npb24uZXhwcmVzc2lvblxuICAgICAgICBhc3NlcnQob2JqZWN0RXhwcmVzc2lvbi50eXBlID09PSAnT2JqZWN0RXhwcmVzc2lvbicpXG4gICAgICAgIGNvbnN0IHByb3BlcnR5ID0gb2JqZWN0RXhwcmVzc2lvbi5wcm9wZXJ0aWVzWzBdXG4gICAgICAgIGFzc2VydChwcm9wZXJ0eS50eXBlID09PSAnU3ByZWFkRWxlbWVudCcpXG5cbiAgICAgICAgT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICBzdGF0ZS5ldmFsdWF0ZXIuZXZhbHVhdGVFeHByZXNzaW9uKHByb3BlcnR5LmFyZ3VtZW50KVxuICAgICAgICApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjcmFzaEVzdHJlZShzdGF0ZSwgbm9kZS5wb3NpdGlvbilcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRm9yIEpTWCwgdGhlIGF1dGhvciBpcyByZXNwb25zaWJsZSBvZiBwYXNzaW5nIGluIHRoZSBjb3JyZWN0IHZhbHVlcy5cbiAgICAgIGNvbnN0IG5hbWUgPSBhdHRyaWJ1dGUubmFtZVxuICAgICAgLyoqIEB0eXBlIHt1bmtub3dufSAqL1xuICAgICAgbGV0IHZhbHVlXG5cbiAgICAgIGlmIChhdHRyaWJ1dGUudmFsdWUgJiYgdHlwZW9mIGF0dHJpYnV0ZS52YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGF0dHJpYnV0ZS52YWx1ZS5kYXRhICYmXG4gICAgICAgICAgYXR0cmlidXRlLnZhbHVlLmRhdGEuZXN0cmVlICYmXG4gICAgICAgICAgc3RhdGUuZXZhbHVhdGVyXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnN0IHByb2dyYW0gPSBhdHRyaWJ1dGUudmFsdWUuZGF0YS5lc3RyZWVcbiAgICAgICAgICBjb25zdCBleHByZXNzaW9uID0gcHJvZ3JhbS5ib2R5WzBdXG4gICAgICAgICAgYXNzZXJ0KGV4cHJlc3Npb24udHlwZSA9PT0gJ0V4cHJlc3Npb25TdGF0ZW1lbnQnKVxuICAgICAgICAgIHZhbHVlID0gc3RhdGUuZXZhbHVhdGVyLmV2YWx1YXRlRXhwcmVzc2lvbihleHByZXNzaW9uLmV4cHJlc3Npb24pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3Jhc2hFc3RyZWUoc3RhdGUsIG5vZGUucG9zaXRpb24pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gYXR0cmlidXRlLnZhbHVlID09PSBudWxsID8gdHJ1ZSA6IGF0dHJpYnV0ZS52YWx1ZVxuICAgICAgfVxuXG4gICAgICAvLyBBc3N1bWUgYSBwcm9wLlxuICAgICAgcHJvcHNbbmFtZV0gPSAvKiogQHR5cGUge1Byb3BzW2tleW9mIFByb3BzXX0gKi8gKHZhbHVlKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwcm9wc1xufVxuXG4vKipcbiAqIENyZWF0ZSBjaGlsZHJlbi5cbiAqXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZVxuICogICBJbmZvIHBhc3NlZCBhcm91bmQuXG4gKiBAcGFyYW0ge1BhcmVudHN9IG5vZGVcbiAqICAgQ3VycmVudCBlbGVtZW50LlxuICogQHJldHVybnMge0FycmF5PENoaWxkPn1cbiAqICAgQ2hpbGRyZW4uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNoaWxkcmVuKHN0YXRlLCBub2RlKSB7XG4gIC8qKiBAdHlwZSB7QXJyYXk8Q2hpbGQ+fSAqL1xuICBjb25zdCBjaGlsZHJlbiA9IFtdXG4gIGxldCBpbmRleCA9IC0xXG4gIC8qKiBAdHlwZSB7TWFwPHN0cmluZywgbnVtYmVyPn0gKi9cbiAgLy8gTm90ZTogdGVzdCB0aGlzIHdoZW4gU29saWQgZG9lc27igJl0IHdhbnQgdG8gbWVyZ2UgbXkgdXBjb21pbmcgUFIuXG4gIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gIGNvbnN0IGNvdW50c0J5TmFtZSA9IHN0YXRlLnBhc3NLZXlzID8gbmV3IE1hcCgpIDogZW1wdHlNYXBcblxuICB3aGlsZSAoKytpbmRleCA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgY29uc3QgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2luZGV4XVxuICAgIC8qKiBAdHlwZSB7c3RyaW5nIHwgdW5kZWZpbmVkfSAqL1xuICAgIGxldCBrZXlcblxuICAgIGlmIChzdGF0ZS5wYXNzS2V5cykge1xuICAgICAgY29uc3QgbmFtZSA9XG4gICAgICAgIGNoaWxkLnR5cGUgPT09ICdlbGVtZW50J1xuICAgICAgICAgID8gY2hpbGQudGFnTmFtZVxuICAgICAgICAgIDogY2hpbGQudHlwZSA9PT0gJ21keEpzeEZsb3dFbGVtZW50JyB8fFxuICAgICAgICAgICAgICBjaGlsZC50eXBlID09PSAnbWR4SnN4VGV4dEVsZW1lbnQnXG4gICAgICAgICAgICA/IGNoaWxkLm5hbWVcbiAgICAgICAgICAgIDogdW5kZWZpbmVkXG5cbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIGNvbnN0IGNvdW50ID0gY291bnRzQnlOYW1lLmdldChuYW1lKSB8fCAwXG4gICAgICAgIGtleSA9IG5hbWUgKyAnLScgKyBjb3VudFxuICAgICAgICBjb3VudHNCeU5hbWUuc2V0KG5hbWUsIGNvdW50ICsgMSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSBvbmUoc3RhdGUsIGNoaWxkLCBrZXkpXG4gICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSBjaGlsZHJlbi5wdXNoKHJlc3VsdClcbiAgfVxuXG4gIHJldHVybiBjaGlsZHJlblxufVxuXG4vKipcbiAqIEhhbmRsZSBhIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7U3RhdGV9IHN0YXRlXG4gKiAgIEluZm8gcGFzc2VkIGFyb3VuZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wXG4gKiAgIEtleS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyIHwgc3RyaW5nPiB8IGJvb2xlYW4gfCBudW1iZXIgfCBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkfSB2YWx1ZVxuICogICBoYXN0IHByb3BlcnR5IHZhbHVlLlxuICogQHJldHVybnMge0ZpZWxkIHwgdW5kZWZpbmVkfVxuICogICBGaWVsZCBmb3IgcnVudGltZSwgb3B0aW9uYWwuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVByb3BlcnR5KHN0YXRlLCBwcm9wLCB2YWx1ZSkge1xuICBjb25zdCBpbmZvID0gZmluZChzdGF0ZS5zY2hlbWEsIHByb3ApXG5cbiAgLy8gSWdub3JlIG51bGxpc2ggYW5kIGBOYU5gIHZhbHVlcy5cbiAgaWYgKFxuICAgIHZhbHVlID09PSBudWxsIHx8XG4gICAgdmFsdWUgPT09IHVuZGVmaW5lZCB8fFxuICAgICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIE51bWJlci5pc05hTih2YWx1ZSkpXG4gICkge1xuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgLy8gQWNjZXB0IGBhcnJheWAuXG4gICAgLy8gTW9zdCBwcm9wcyBhcmUgc3BhY2Utc2VwYXJhdGVkLlxuICAgIHZhbHVlID0gaW5mby5jb21tYVNlcGFyYXRlZCA/IGNvbW1hcyh2YWx1ZSkgOiBzcGFjZXModmFsdWUpXG4gIH1cblxuICAvLyBSZWFjdCBvbmx5IGFjY2VwdHMgYHN0eWxlYCBhcyBvYmplY3QuXG4gIGlmIChpbmZvLnByb3BlcnR5ID09PSAnc3R5bGUnKSB7XG4gICAgbGV0IHN0eWxlT2JqZWN0ID1cbiAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgPyB2YWx1ZSA6IHBhcnNlU3R5bGUoc3RhdGUsIFN0cmluZyh2YWx1ZSkpXG5cbiAgICBpZiAoc3RhdGUuc3R5bGVQcm9wZXJ0eU5hbWVDYXNlID09PSAnY3NzJykge1xuICAgICAgc3R5bGVPYmplY3QgPSB0cmFuc2Zvcm1TdHlsZXNUb0Nzc0Nhc2luZyhzdHlsZU9iamVjdClcbiAgICB9XG5cbiAgICByZXR1cm4gWydzdHlsZScsIHN0eWxlT2JqZWN0XVxuICB9XG5cbiAgcmV0dXJuIFtcbiAgICBzdGF0ZS5lbGVtZW50QXR0cmlidXRlTmFtZUNhc2UgPT09ICdyZWFjdCcgJiYgaW5mby5zcGFjZVxuICAgICAgPyBoYXN0VG9SZWFjdFtpbmZvLnByb3BlcnR5XSB8fCBpbmZvLnByb3BlcnR5XG4gICAgICA6IGluZm8uYXR0cmlidXRlLFxuICAgIHZhbHVlXG4gIF1cbn1cblxuLyoqXG4gKiBQYXJzZSBhIENTUyBkZWNsYXJhdGlvbiB0byBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtTdGF0ZX0gc3RhdGVcbiAqICAgSW5mbyBwYXNzZWQgYXJvdW5kLlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiAgIENTUyBkZWNsYXJhdGlvbnMuXG4gKiBAcmV0dXJucyB7U3R5bGV9XG4gKiAgIFByb3BlcnRpZXMuXG4gKiBAdGhyb3dzXG4gKiAgIFRocm93cyBgVkZpbGVNZXNzYWdlYCB3aGVuIENTUyBjYW5ub3QgYmUgcGFyc2VkLlxuICovXG5mdW5jdGlvbiBwYXJzZVN0eWxlKHN0YXRlLCB2YWx1ZSkge1xuICAvKiogQHR5cGUge1N0eWxlfSAqL1xuICBjb25zdCByZXN1bHQgPSB7fVxuXG4gIHRyeSB7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogYHN0eWxlLXRvLW9iamVjdGAgdHlwZXMgYXJlIGJyb2tlbi5cbiAgICBzdHlsZVRvT2JqZWN0KHZhbHVlLCByZXBsYWNlcilcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoIXN0YXRlLmlnbm9yZUludmFsaWRTdHlsZSkge1xuICAgICAgY29uc3QgY2F1c2UgPSAvKiogQHR5cGUge0Vycm9yfSAqLyAoZXJyb3IpXG4gICAgICBjb25zdCBtZXNzYWdlID0gbmV3IFZGaWxlTWVzc2FnZSgnQ2Fubm90IHBhcnNlIGBzdHlsZWAgYXR0cmlidXRlJywge1xuICAgICAgICBhbmNlc3RvcnM6IHN0YXRlLmFuY2VzdG9ycyxcbiAgICAgICAgY2F1c2UsXG4gICAgICAgIHJ1bGVJZDogJ3N0eWxlJyxcbiAgICAgICAgc291cmNlOiAnaGFzdC11dGlsLXRvLWpzeC1ydW50aW1lJ1xuICAgICAgfSlcbiAgICAgIG1lc3NhZ2UuZmlsZSA9IHN0YXRlLmZpbGVQYXRoIHx8IHVuZGVmaW5lZFxuICAgICAgbWVzc2FnZS51cmwgPSBkb2NzICsgJyNjYW5ub3QtcGFyc2Utc3R5bGUtYXR0cmlidXRlJ1xuXG4gICAgICB0aHJvdyBtZXNzYWdlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxuXG4gIC8qKlxuICAgKiBBZGQgYSBDU1MgcHJvcGVydHkgKG5vcm1hbCwgc28gd2l0aCBkYXNoZXMpIHRvIGByZXN1bHRgIGFzIGEgRE9NIENTU1xuICAgKiBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogICBLZXkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKiAgIFZhbHVlXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAqICAgTm90aGluZy5cbiAgICovXG4gIGZ1bmN0aW9uIHJlcGxhY2VyKG5hbWUsIHZhbHVlKSB7XG4gICAgbGV0IGtleSA9IG5hbWVcblxuICAgIGlmIChrZXkuc2xpY2UoMCwgMikgIT09ICctLScpIHtcbiAgICAgIGlmIChrZXkuc2xpY2UoMCwgNCkgPT09ICctbXMtJykga2V5ID0gJ21zLScgKyBrZXkuc2xpY2UoNClcbiAgICAgIGtleSA9IGtleS5yZXBsYWNlKGRhc2hTb21ldGhpbmcsIHRvQ2FtZWwpXG4gICAgfVxuXG4gICAgcmVzdWx0W2tleV0gPSB2YWx1ZVxuICB9XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgSlNYIG5hbWUgZnJvbSBhIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZVxuICogICBUbyBkby5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiAgIE5hbWUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGFsbG93RXhwcmVzc2lvblxuICogICBBbGxvdyBtZW1iZXIgZXhwcmVzc2lvbnMgYW5kIGlkZW50aWZpZXJzLlxuICogQHJldHVybnMge3Vua25vd259XG4gKiAgIFRvIGRvLlxuICovXG5mdW5jdGlvbiBmaW5kQ29tcG9uZW50RnJvbU5hbWUoc3RhdGUsIG5hbWUsIGFsbG93RXhwcmVzc2lvbikge1xuICAvKiogQHR5cGUge0lkZW50aWZpZXIgfCBMaXRlcmFsIHwgTWVtYmVyRXhwcmVzc2lvbn0gKi9cbiAgbGV0IHJlc3VsdFxuXG4gIGlmICghYWxsb3dFeHByZXNzaW9uKSB7XG4gICAgcmVzdWx0ID0ge3R5cGU6ICdMaXRlcmFsJywgdmFsdWU6IG5hbWV9XG4gIH0gZWxzZSBpZiAobmFtZS5pbmNsdWRlcygnLicpKSB7XG4gICAgY29uc3QgaWRlbnRpZmllcnMgPSBuYW1lLnNwbGl0KCcuJylcbiAgICBsZXQgaW5kZXggPSAtMVxuICAgIC8qKiBAdHlwZSB7SWRlbnRpZmllciB8IExpdGVyYWwgfCBNZW1iZXJFeHByZXNzaW9uIHwgdW5kZWZpbmVkfSAqL1xuICAgIGxldCBub2RlXG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGlkZW50aWZpZXJzLmxlbmd0aCkge1xuICAgICAgLyoqIEB0eXBlIHtJZGVudGlmaWVyIHwgTGl0ZXJhbH0gKi9cbiAgICAgIGNvbnN0IHByb3AgPSBpc0lkZW50aWZpZXJOYW1lKGlkZW50aWZpZXJzW2luZGV4XSlcbiAgICAgICAgPyB7dHlwZTogJ0lkZW50aWZpZXInLCBuYW1lOiBpZGVudGlmaWVyc1tpbmRleF19XG4gICAgICAgIDoge3R5cGU6ICdMaXRlcmFsJywgdmFsdWU6IGlkZW50aWZpZXJzW2luZGV4XX1cbiAgICAgIG5vZGUgPSBub2RlXG4gICAgICAgID8ge1xuICAgICAgICAgICAgdHlwZTogJ01lbWJlckV4cHJlc3Npb24nLFxuICAgICAgICAgICAgb2JqZWN0OiBub2RlLFxuICAgICAgICAgICAgcHJvcGVydHk6IHByb3AsXG4gICAgICAgICAgICBjb21wdXRlZDogQm9vbGVhbihpbmRleCAmJiBwcm9wLnR5cGUgPT09ICdMaXRlcmFsJyksXG4gICAgICAgICAgICBvcHRpb25hbDogZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIDogcHJvcFxuICAgIH1cblxuICAgIGFzc2VydChub2RlLCAnYWx3YXlzIGEgcmVzdWx0JylcbiAgICByZXN1bHQgPSBub2RlXG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ID1cbiAgICAgIGlzSWRlbnRpZmllck5hbWUobmFtZSkgJiYgIS9eW2Etel0vLnRlc3QobmFtZSlcbiAgICAgICAgPyB7dHlwZTogJ0lkZW50aWZpZXInLCBuYW1lfVxuICAgICAgICA6IHt0eXBlOiAnTGl0ZXJhbCcsIHZhbHVlOiBuYW1lfVxuICB9XG5cbiAgLy8gT25seSBsaXRlcmFscyBjYW4gYmUgcGFzc2VkIGluIGBjb21wb25lbnRzYCBjdXJyZW50bHkuXG4gIC8vIE5vIGlkZW50aWZpZXJzIC8gbWVtYmVyIGV4cHJlc3Npb25zLlxuICBpZiAocmVzdWx0LnR5cGUgPT09ICdMaXRlcmFsJykge1xuICAgIGNvbnN0IG5hbWUgPSAvKiogQHR5cGUge2tleW9mIEpTWC5JbnRyaW5zaWNFbGVtZW50c30gKi8gKHJlc3VsdC52YWx1ZSlcblxuICAgIHJldHVybiBvd24uY2FsbChzdGF0ZS5jb21wb25lbnRzLCBuYW1lKSA/IHN0YXRlLmNvbXBvbmVudHNbbmFtZV0gOiBuYW1lXG4gIH1cblxuICAvLyBBc3N1bWUgY29tcG9uZW50LlxuICBpZiAoc3RhdGUuZXZhbHVhdGVyKSB7XG4gICAgcmV0dXJuIHN0YXRlLmV2YWx1YXRlci5ldmFsdWF0ZUV4cHJlc3Npb24ocmVzdWx0KVxuICB9XG5cbiAgY3Jhc2hFc3RyZWUoc3RhdGUpXG59XG5cbi8qKlxuICogQHBhcmFtIHtTdGF0ZX0gc3RhdGVcbiAqIEBwYXJhbSB7UG9zaXRpb24gfCB1bmRlZmluZWR9IFtwbGFjZV1cbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZnVuY3Rpb24gY3Jhc2hFc3RyZWUoc3RhdGUsIHBsYWNlKSB7XG4gIGNvbnN0IG1lc3NhZ2UgPSBuZXcgVkZpbGVNZXNzYWdlKFxuICAgICdDYW5ub3QgaGFuZGxlIE1EWCBlc3RyZWVzIHdpdGhvdXQgYGNyZWF0ZUV2YWx1YXRlcmAnLFxuICAgIHtcbiAgICAgIGFuY2VzdG9yczogc3RhdGUuYW5jZXN0b3JzLFxuICAgICAgcGxhY2UsXG4gICAgICBydWxlSWQ6ICdtZHgtZXN0cmVlJyxcbiAgICAgIHNvdXJjZTogJ2hhc3QtdXRpbC10by1qc3gtcnVudGltZSdcbiAgICB9XG4gIClcbiAgbWVzc2FnZS5maWxlID0gc3RhdGUuZmlsZVBhdGggfHwgdW5kZWZpbmVkXG4gIG1lc3NhZ2UudXJsID0gZG9jcyArICcjY2Fubm90LWhhbmRsZS1tZHgtZXN0cmVlcy13aXRob3V0LWNyZWF0ZWV2YWx1YXRlcidcblxuICB0aHJvdyBtZXNzYWdlXG59XG5cbi8qKlxuICogVHJhbnNmb3JtIGEgRE9NIGNhc2luZyBzdHlsZSBvYmplY3QgdG8gYSBDU1MgY2FzaW5nIHN0eWxlIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge1N0eWxlfSBkb21DYXNpbmdcbiAqIEByZXR1cm5zIHtTdHlsZX1cbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtU3R5bGVzVG9Dc3NDYXNpbmcoZG9tQ2FzaW5nKSB7XG4gIC8qKiBAdHlwZSB7U3R5bGV9ICovXG4gIGNvbnN0IGNzc0Nhc2luZyA9IHt9XG4gIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICBsZXQgZnJvbVxuXG4gIGZvciAoZnJvbSBpbiBkb21DYXNpbmcpIHtcbiAgICBpZiAob3duLmNhbGwoZG9tQ2FzaW5nLCBmcm9tKSkge1xuICAgICAgY3NzQ2FzaW5nW3RyYW5zZm9ybVN0eWxlVG9Dc3NDYXNpbmcoZnJvbSldID0gZG9tQ2FzaW5nW2Zyb21dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNzc0Nhc2luZ1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybSBhIERPTSBjYXNpbmcgc3R5bGUgZmllbGQgdG8gYSBDU1MgY2FzaW5nIHN0eWxlIGZpZWxkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBmcm9tXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdHlsZVRvQ3NzQ2FzaW5nKGZyb20pIHtcbiAgbGV0IHRvID0gZnJvbS5yZXBsYWNlKGNhcCwgdG9EYXNoKVxuICAvLyBIYW5kbGUgYG1zLXh4eGAgLT4gYC1tcy14eHhgLlxuICBpZiAodG8uc2xpY2UoMCwgMykgPT09ICdtcy0nKSB0byA9ICctJyArIHRvXG4gIHJldHVybiB0b1xufVxuXG4vKipcbiAqIE1ha2UgYCQxYCBjYXBpdGFsaXplZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gX1xuICogICBXaGF0ZXZlci5cbiAqIEBwYXJhbSB7c3RyaW5nfSAkMVxuICogICBTaW5nbGUgQVNDSUkgYWxwaGFiZXRpY2FsLlxuICogQHJldHVybnMge3N0cmluZ31cbiAqICAgQ2FwaXRhbGl6ZWQgYCQxYC5cbiAqL1xuZnVuY3Rpb24gdG9DYW1lbChfLCAkMSkge1xuICByZXR1cm4gJDEudG9VcHBlckNhc2UoKVxufVxuXG4vKipcbiAqIE1ha2UgYCQwYCBkYXNoIGNhc2VkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSAkMFxuICogICBDYXBpdGFsaXplZCBBU0NJSSBsZXRlci5cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKiAgIERhc2ggYW5kIGxvd2VyIGxldHRlci5cbiAqL1xuZnVuY3Rpb24gdG9EYXNoKCQwKSB7XG4gIHJldHVybiAnLScgKyAkMC50b0xvd2VyQ2FzZSgpXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/hast-util-to-jsx-runtime/lib/index.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/hast-util-to-jsx-runtime/node_modules/style-to-object/esm/index.mjs":
/*!*******************************************************************************************!*\
  !*** ../node_modules/hast-util-to-jsx-runtime/node_modules/style-to-object/esm/index.mjs ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _cjs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../cjs/index.js */ \"(rsc)/../node_modules/hast-util-to-jsx-runtime/node_modules/style-to-object/cjs/index.js\");\n\n\n// ensure compatibility with rollup umd build\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_cjs_index_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] || _cjs_index_js__WEBPACK_IMPORTED_MODULE_0__);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2hhc3QtdXRpbC10by1qc3gtcnVudGltZS9ub2RlX21vZHVsZXMvc3R5bGUtdG8tb2JqZWN0L2VzbS9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBNEM7O0FBRTVDO0FBQ0EsaUVBQWUscURBQXFCLElBQUksMENBQWEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2dpdGh1Yl9teV9wb3J0Zm9saW8vLi4vbm9kZV9tb2R1bGVzL2hhc3QtdXRpbC10by1qc3gtcnVudGltZS9ub2RlX21vZHVsZXMvc3R5bGUtdG8tb2JqZWN0L2VzbS9pbmRleC5tanM/OGQ3NSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgU3R5bGVUb09iamVjdCBmcm9tICcuLi9janMvaW5kZXguanMnO1xuXG4vLyBlbnN1cmUgY29tcGF0aWJpbGl0eSB3aXRoIHJvbGx1cCB1bWQgYnVpbGRcbmV4cG9ydCBkZWZhdWx0IFN0eWxlVG9PYmplY3QuZGVmYXVsdCB8fCBTdHlsZVRvT2JqZWN0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/hast-util-to-jsx-runtime/node_modules/style-to-object/esm/index.mjs\n");

/***/ })

};
;